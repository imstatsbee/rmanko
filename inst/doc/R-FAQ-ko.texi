\input texinfo
@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================


@c %**start of header
@setfilename R-FAQ.info
@settitle R FAQ (translated in Korean)
@setchapternewpage on
@set FAQ_YEAR 2022
@set FAQ_DATE @value{FAQ_YEAR}-09-08
@set FAQ_VERSION @value{FAQ_DATE}
@c %**end of header
@documentlanguage en

@dircategory Programming
@direntry
* R FAQ: (R-FAQ).            The R statistical system FAQ.
@end direntry

@finalout

@macro SPLUS{}
@sc{S-Plus}
@end macro

@macro CRAN{}
@acronym{CRAN}
@end macro

@macro HTML{}
@acronym{HTML}
@end macro

@macro FORTRAN{}
FORTRAN
@end macro

@macro XML{}
@acronym{XML}
@end macro

@macro XSL{}
@acronym{XSL}
@end macro

@macro pkg {p}
@strong{\p\}
@end macro

@macro CRANpkg {p}
@url{https://CRAN.R-project.org/package=\p\, @strong{\p\}}
@end macro

@macro doi {d}
doi:@tie{}@url{https://doi.org/\d\, \d\}
@end macro

@macro Rcopyright{year}
Copyright @copyright{} \year\--@value{FAQ_YEAR} R Core Team
@end macro

@titlepage
@title R @acronym{FAQ}
@subtitle R에 관하여 자주 물어보는 질문들
@subtitle Version @value{FAQ_VERSION}
@author Kurt Hornik
@author and the R Core Team
@end titlepage

@ifinfo
@c We do not really see this in info, but in plain text output.
R FAQ @* Frequently Asked Questions on R @* Version @value{FAQ_VERSION} @*
Kurt Hornik and the R Core Team @*

@sp 2
@end ifinfo

@ifhtml
@html
 <h2>Frequently Asked Questions on R</h2> <h3 style="text-align:
center;">Version @value{FAQ_VERSION}</h3> <h3 style="text-align:
center;">Kurt Hornik and the R Core Team</h3> <hr>
@end html
@end ifhtml

@c @ifnothtml
@contents

@include version.texi
@include R-intro-notification.texi

@notification{}


@c @end ifnothtml

@ifnottex
@node Top, 소개, (dir), (dir)
@top R FAQ (translated in Korean)
@end ifnottex

@menu
* 소개::
* R 기초::
* R과 S::
* R 웹인터페이스(Web Interfaces)::
* R Add-On Packages::
* R과 이맥스(Emacs)::
* R 기타사항들(Miscellanea)::
* R 프로그래밍(Programming)::
* R 버그(Bugs)::
* 감사의 말씀(Acknowledgements)::  
@end menu

@node 소개, R 기초, Top, Top
@chapter 소개

이 문서는 R에 관하여 가장 많이 자주 물어보는 질문들에 대해서 정리한 문서입니다.

@menu
* 법률적 사항(Legalese)::
* 이 문서를 얻는 방법::
* 이 문서를 인용하는 방법::
* 표기법(Notation)::
* 피드백(Feedback)::      
@end menu

@node 법률적 사항(Legalese), 이 문서를 얻는 방법, 소개, 소개
@section 법률적 사항(Legalese)

Copyright @copyright{} 1998--2020 Kurt Hornik @* @Rcopyright{2021}

본 문서는 자유소프트웨어(free software)이므로, 자유소프트웨어 재단 (Free Software Foundation)에 의해서
배포되는 @acronym{GNU} 일반공중라이센스 (General Public License) 버전 2 또는 그 이후의 버전들을 통하여
수정 및 재배포를 할 수 있습니다. 

이 문서가 사용자에게 유용하길 바라는 희망에서 배포되고 있습니다. 그러나, 어떤 상업적 형태(MERCHANTABILITY)로서의 보증 및
특수한 목적에 적합(FITNESS FOR A PARTICULAR PURPOSES)등 어떠한 형태의 보증을 하지 않습니다.  보다 자세한
사항들은 @acronym{GNU} 일반공증라이센스를 참조하시길 부탁드립니다. 

@acronym{GNU} 일반공증라이센스의 사본들을 아래의 주소로부터 찾으실 수 있습니다.

@display
@url{https://www.R-project.org/Licenses/}
@end display


@node 이 문서를 얻는 방법, 이 문서를 인용하는 방법, 법률적 사항(Legalese), 소개
@section 이 문서를 얻는 방법

가장 최신 버전의 문서는 항상 아래의 주소에서 확인이 가능합니다.

@display
@url{https://CRAN.R-project.org/doc/FAQ/}
@end display

@c @url{https://CRAN.R-project.org/doc/FAQ/R-FAQ.dvi.gz,, DVI},
@c @url{https://CRAN.R-project.org/doc/FAQ/R-FAQ.ps.gz,, PostScript}
From there, you can obtain versions converted to
@url{https://CRAN.R-project.org/doc/FAQ/R-FAQ.txt,, plain @acronym{ASCII}
text}, @url{https://CRAN.R-project.org/doc/FAQ/R-FAQ.info.gz,, @acronym{GNU}
info}, @url{https://CRAN.R-project.org/doc/FAQ/R-FAQ.html,, @HTML{}},
@url{https://CRAN.R-project.org/doc/FAQ/R-FAQ.pdf,, PDF}, as well as the
@url{https://CRAN.R-project.org/doc/FAQ/R-FAQ.texi,, Texinfo source} used
for creating all these formats using the @acronym{GNU} Texinfo system.

그외에도 R @acronym{FAQ} 문서를 @CRAN{} 사이트 (@pxref{CRAN이란 무엇인가요?} 참조)의 하위디렉토리
@file{doc/FAQ}에서 찾을 수 있습니다.

@node 이 문서를 인용하는 방법, 표기법(Notation), 이 문서를 얻는 방법, 소개
@section 이 문서를 인용하는 방법

In publications, please refer to this @acronym{FAQ} as Hornik and R Core
Team (@value{FAQ_YEAR}), ``The R @acronym{FAQ}'', and give the above,
@emph{official} @acronym{URL}:

@example
@group
@@Misc@{,
  author        = @{Kurt Hornik and the R Core Team@},
  title         = @{@{R@} @{FAQ@}@},
  year          = @{@value{FAQ_YEAR}@},
  url           = @{https://CRAN.R-project.org/doc/FAQ/R-FAQ.html@}
@}
@end group
@end example


@node 표기법(Notation), 피드백(Feedback), 이 문서를 인용하는 방법, 소개
@section 표기법(Notation)

이 문서에서는 거의 대부분이 표준에 가까운 표기법을 사용합니다.  예를들면, @samp{R>}은 R 프롬프트(prompt)를 나타내고,
@samp{$}는 쉘프롬프트(shell prompt)를 의미합니다.

@node 피드백(Feedback), , 표기법(Notation), 소개
@section 피드백(Feedback)

Feedback via email to @email{R-devel@@R-project.org} is most welcome.

Features specific to the Windows and macOS ports of R are described in the
@url{https://CRAN.R-project.org/bin/windows/base/rw-FAQ.html, ``R for
Windows @acronym{FAQ}''} and the
@url{https://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html, ``R for Mac OS
X @acronym{FAQ}''}.  If you have information on Mac or Windows systems that
you think should be added to this document, please let us know.

@c <FIXME>
@c Should we maybe have direct links inside the R tree to the various
@c rw-FAQ versions?
@c </FIXME>

@node R 기초, R과 S, 소개, Top
@chapter R 기초

@menu
* R이란 무엇인가요?::
* R은 어떤 플랫폼에서 사용가능한가요?::
* 현재 배포된 R의 버전은 무엇인가요?::
* 어떻게 R을 얻을 수 있나요?::
* R의 설치는 어떻게 하나요?::
* R을 유닉스와 같은 환경에서 사용할 수 있도록 바이너리 파일이 제공되나요?::
* What documentation exists for R?::
* R을 인용하는 방법::
* R과 관련하여 어떤 메일링 리스트들이 있나요?::
* CRAN이란 무엇인가요?::
* R을 상업적 용도로 사용할 수 있나요?::
* 왜 R이라고 이름을 짓게 되었나요?::
* R 재단(Foundation)은 무엇을 말하나요?::
* R-Forge는 무엇인가요?::  
@end menu

@node R이란 무엇인가요?, R은 어떤 플랫폼에서 사용가능한가요?, R 기초, R 기초
@section R이란 무엇인가요?

R은 통계 계산 (statistical computation)과 그래픽 (graphics)를 위한 시스템입니다.  이것은
언어(language), 그래픽을 사용하는 실행환경 (run-time environment), 디버거(debugger), 특정시스템
함수들에 대한 접근, 그리고 스크립트 파일들에 저장되어 있는 프로그램들을 실행시키는 요소들로 구성되어 있습니다.

The design of R has been heavily influenced by two existing languages:
Becker, Chambers & Wilks' S (@pxref{What is S?}) and Sussman's
@url{http://community.schemewiki.org/?scheme-faq, Scheme}.  Whereas the
resulting language is very similar in appearance to S, the underlying
implementation and semantics are derived from Scheme.  @xref{What are the
differences between R and S?}, for further details.

R의 핵심은 인터프리트된 컴퓨터 언어 (interpreted computer language)입니다.  이것은 분기(branching),
루핑(Looping) 그리고 함수(functions)를 이용한 모듈(modular) 프로그래밍을 가능하게 합니다.  R에서 사용자가
사용하는 함수들의 대부분은 R로 작성되었습니다.  또한, 사용자가 효율성(efficiency)를 위한 목적으로 C, C++, 또는
FORTRAN과 같은 언어로 작성된 프로시져들에 인터페이싱(interface)하는 것이 가능합니다.  R 배포판
(distribution)은 방대한 양의 통계적 프로시져(statistical procedure)들을 위한
기능(functionalities)들을 포함하고 있습니다.  이들중에는 선형 및 일반화 선형 모델 (linear and
generalized linear models), 비선형모델 (nonlinear regression model), 시계열분석 (time
series analysis), 전통적인 모수 및 비모수 테스트 (classical parametric and nonparametric
tests), 클러스터링 (clustering)과 평활화 (smoothing)이 있습니다.  또한 매우 다양한 종류의 데이터 시각적
표현들을 생성할 수 있는 매우 유연한 그래픽 환경을 제공해주는 방대한 양의 함수들의 집합이 있습니다.  특수한 목적을 달성하기 위해서
개발된 애드온 패키지(``add-on packages'')로 알려져 있는 부가적인 모듈들 역시 이용이 가능합니다.  (이들에 대해서 더
알고 싶으시면 @pxref{R Add-On Packages}를 참고해주세요).

최초의 R은 @email{Ross.Ihaka@@R-project.org, Ross Ihaka}와
@email{Robert.Gentleman@@R-project.org, Robert Gentleman}가 New Zealand의
Auckland 에 있는 University of Auckland의 통계학과에 재직중일 당시 작성되었습니다.  그 이후, 많은 사용자들이
코드를 제공하고 버그를 리포팅 함으로서 R에 기여 해왔습니다. 

Since mid-1997 there has been a core group (the ``R Core Team'') who can
modify the R source code archive.  The group currently consists of Doug
Bates, John Chambers, Peter Dalgaard, Robert Gentleman, Kurt Hornik, Ross
Ihaka, Tomas Kalibera, Michael Lawrence, Friedrich Leisch, Uwe Ligges,
Thomas Lumley, Martin Maechler, Sebastian Meyer, Paul Murrell, Martyn
Plummer, Brian Ripley, Deepayan Sarkar, Duncan Temple Lang, Luke Tierney,
and Simon Urbanek.

R has a home page at @url{https://www.R-project.org/}.  It is
@url{https://www.gnu.org/philosophy/free-sw.html, free software} distributed
under a @acronym{GNU}-style @url{https://www.gnu.org/copyleft/copyleft.html,
copyleft}, and an official part of the @url{https://www.gnu.org/,
@acronym{GNU}} project (``@acronym{GNU} S'').

@node R은 어떤 플랫폼에서 사용가능한가요?, 현재 배포된 R의 버전은 무엇인가요?, R이란 무엇인가요?, R 기초
@section R은 어떤 플랫폼에서 사용가능한가요?

R은 Unix, Windows와 Mac 계열의 환경에서 개발되어져 왔습니다.  R 1.7.1 이후로는 Mac OS Classic 에 대한
지원이 종료되었습니다.

@c <FIXME>
@c Not sure anymore ...
@c alpha-dec-osf4,
@c <COMMENT>
@c i386-freebsd reported by B. Gian James" <gian.james@gmail.com> on
@c 2009-01-11
@c (Architecture: i386, OS: FreeBSD 7.1-PRERELEASE, Vendor: PC-BSD)
@c i386-freebsd,
@c but all recent reports are on x86_64
@c </COMMENT>
@c hppa-hp-hpux, 
@c mips-sgi-irix,
@c </FIXME>
The current version of R will configure and build under a number of common
Unix-like (e.g., @uref{https://en.wikipedia.org/wiki/Unix-like})  platforms
including @var{cpu}-linux-gnu for the i386, amd64/x86_64, alpha, arm, arm64,
hppa, mips/mipsel, powerpc, s390x and sparc @acronym{CPU}s (e.g.,
@url{https://buildd.debian.org/build.php?&pkg=r-base}), i386-hurd-gnu,
@var{cpu}-kfreebsd-gnu for i386 and amd64, i386-pc-solaris, rs6000-ibm-aix,
sparc-sun-solaris, x86_64-apple-darwin, aarch64-apple-darwin,
x86_64-unknown-freebsd and x86_64-unknown-openbsd.

@c and according to @email{jlindsey@@luc.ac.be, Jim Lindsey} also on
@c Mac, Amiga and Atari under m68k-linux.

혹시 다른 플랫폼을 알고 계시다면, 저희에게 알려주십시요.

@node 현재 배포된 R의 버전은 무엇인가요?, 어떻게 R을 얻을 수 있나요?, R은 어떤 플랫폼에서 사용가능한가요?, R 기초
@section 현재 배포된 R의 버전은 무엇인가요?
 
R uses a `major.minor.patchlevel' numbering scheme.  Based on this, there
are the current release version of R (`r-release') as well as two
development versions of R, a patched version of the current release
(`r-patched') and one working towards the next minor or eventually major
(`r-devel') releases of R, respectively.  New features are typically
introduced in r-devel, while r-patched is for bug fixes mostly.

See @url{https://CRAN.R-project.org/sources.html} for the current versions
of r-release, r-patched and r-devel.

@node 어떻게 R을 얻을 수 있나요?, R의 설치는 어떻게 하나요?, 현재 배포된 R의 버전은 무엇인가요?, R 기초
@section 어떻게 R을 얻을 수 있나요?

R 원시코드 (sources), 바이너리 (binaries), 그리고 문서들(documentation)은
@CRAN{}(``Comprehensive R Archive Network'')을 통하여 얻을 수 있습니다. (@ref{CRAN이란
무엇인가요?}을 살펴보세요).

원시코드 (sources)는 또한 R 서브버전 저장소 (subversion repository)인
@url{https://svn.R-project.org/R/}를 통하여 얻을 수 있습니다.  그러나, 익명 rsync (그리고 CVS)를
사용할 수 없습니다.

Tarballs with daily snapshots of the r-devel and r-patched development
versions of R can be found at @url{https://stat.ethz.ch/R/daily/}.

@c Sources are also available via anonymous rsync.  Use

@c @example
@c rsync -rptC --delete rsync.R-project.org::@var{module} R
@c @end example

@c @noindent
@c to create a copy of the source tree specified by @var{module} in the
@c subdirectory @file{R} of the current directory, where @var{module}
@c specifies one of the three existing flavors of the R sources, and can be
@c one of @samp{r-release} (current released version), @samp{r-patched}
@c (patched released version), and @samp{r-devel} (development version).
@c The rsync trees are created directly from the master CVS archive and are
@c updated hourly.  The @option{-C} and in the @command{rsync} command
@c is to cause it to skip the CVS directories.  Further information on
@c @command{rsync} is available at @url{http://rsync.samba.org/rsync/}.

@c @c <NOTE>
@c @c Keep in sync with R-admin.
@c Note that the sources available via rsync do not include the recommended
@c packages, whereas these are included in the tarballs of released
@c versions.  To install the appropriate sources for the recommended
@c packages, run @command{./tools/rsync-recommended} from the top-level of
@c the R sources that you pulled by rsync.
@c @c </NOTE>

@c The sources of the development version are also available via anonymous
@c CVS.  See @url{http://anoncvs.R-project.org} for more information.

@node R의 설치는 어떻게 하나요?, R을 유닉스와 같은 환경에서 사용할 수 있도록 바이너리 파일이 제공되나요?, 어떻게 R을 얻을 수 있나요?, R 기초
@section R의 설치는 어떻게 하나요?

@menu
* 어떻게 R을 설치하나요? (유닉스와 같은 환경)::
* 어떻게 R을 설치하나요? (윈도우즈 환경)::
* 어떻게 R을 설치하나요? (Mac)::  
@end menu

@node 어떻게 R을 설치하나요? (유닉스와 같은 환경), 어떻게 R을 설치하나요? (윈도우즈 환경), R의 설치는 어떻게 하나요?, R의 설치는 어떻게 하나요?
@subsection 어떻게 R을 설치하나요? (유닉스와 같은 환경)

만약 R이 이미 설치되어 있다면, 쉘 프롬프트(shell prompt)에서 @kbd{R}이라고 입력을 함으로서 실행할 수 있습니다
(물론, 실행가능한 파일이 경로에 올바르게 위치해 있다는 가정하에서 입니다). 

만약 사용자의 플랫폼에 바이너리(binaries)가 사용가능하다면 (@ref{R을 유닉스와 같은 환경에서 사용할 수 있도록 바이너리
파일이 제공되나요?} 섹션을 살펴보세요), 이와 함께 제공되는 지시사항들을 따른다면 이들을 사용할 수 있습니다.

그렇지 않다면, R을 직접 컴파일하여 설치하여야 합니다.  일반적인 Unix와 같은 플랫폼(@ref{R은 어떤 플랫폼에서
사용가능한가요?}를 참고해주세요)에서 이 과정을 수행하는 것은 매우 쉽쉽니다.  R의 배포판과 함께 제공되는 @file{INSTALL}
파일은 간단한 설치지침을 포함하고 있으면 ``R Installation and Administration''라는 가이드는 설치와 관련한
자세한 내용들이 잘 문서화 되어 있습니다 (@pxref{What documentation exists for R?}을 참고하세요).

Note that you need a @FORTRAN{} 90 compiler as well as a C compiler to build
R.

가장 간단한 방법은 R 원시코드(source code)의 압축을 풀고, 압축이 풀어 생성된 디렉토리로 이동한 후, (쉘 프롬프트상에서)
다음과 같은 명령어를 입력하는 것입니다.

@example
$ ./configure
$ make
@end example

If these commands execute successfully, the R binary and a shell script
front-end called @file{R} are created and copied to the @file{bin}
directory.  You can copy the script to a place where users can invoke it,
for example to @file{/usr/local/bin}.  In addition, @HTML{} versions of the
R manuals (e.g., @file{R-exts.html}, the ``Writing R Extensions'' manual)
are built in the @file{doc/manual} subdirectory.

Use @kbd{make pdf} to build PDF (Portable Document Format)  versions of the
R manuals, including @file{fullrefman.pdf} (an R object reference index).
Manuals written in the @acronym{GNU} Texinfo system can also be converted to
info files suitable for reading online with Emacs or stand-alone
@acronym{GNU} Info; use @kbd{make info} to create these versions (note that
this requires Makeinfo version 4.5).

마지막으로 R 시스템이 정상적으로 작동하는지 확인하기 위해서 @kbd{make check}를 이용해 보세요.

@kbd{make install}을 이용하여 ``system-wide''(시스템 전체에서 사용이 가능한) 설치를 수행할 수도
있습니다. 기본적으로 이것은 다음의 디렉토리에 설치됩니다. 

@table @file
@item $@{prefix@}/bin
사용자가 직접 이용하는 쉘 스크립트
@item $@{prefix@}/man/man1
man 페이지
@item $@{prefix@}/lib/R
위의 내용을 제외한 나머지 모두 (라이브러리, 온라인 도움말, @dots{})이 이곳에 설치됩니다. 이것을 설치된 시스템의 ``R
Home Directory''(R 홈디렉토리, @env{R_HOME})이라고 합니다. 
@end table

@noindent
위에서 @code{prefix}는 환경설정을 하는 동안에 결정되어 지며 (일반적으로 @file{/usr/local/}입니다), 아래에
보이는 것과 같이 @command{configure}에 옵션을 이용하여 설치시에 정할 수도 있습니다.

@example
$ ./configure --prefix=/where/you/want/R/to/go
@end example

@noindent
(즉, R의 실행파일들은 @file{/where/you/want/R/to/go/bin}에 설치될 것입니다).

To install info and PDF versions of the manuals, use @kbd{make install-info}
and @kbd{make install-pdf}, respectively.

@node 어떻게 R을 설치하나요? (윈도우즈 환경), 어떻게 R을 설치하나요? (Mac), 어떻게 R을 설치하나요? (유닉스와 같은 환경), R의 설치는 어떻게 하나요?
@subsection 어떻게 R을 설치하나요? (윈도우즈 환경)

The @file{bin/windows} directory of a @CRAN{} site contains binaries for a
base distribution and add-on packages from @CRAN{} to run on 64-bit versions
of Windows 7 and later on x86_64 chips (R 4.1.3 was the last version of R to
support 32-bit Windows).  The Windows version of R was created by Robert
Gentleman and Guido Masarotto; Brian Ripley and Duncan Murdoch made
substantial contributions and it is now being maintained by other members of
the R Core team.

대부분의 경우, Windows 설치 프로그램 (installer)은 이용하기에 가장 쉬운 도구일 것입니다.

See the @url{https://CRAN.R-project.org/bin/windows/base/rw-FAQ.html, ``R
for Windows @acronym{FAQ}''} for more details.

@node 어떻게 R을 설치하나요? (Mac), , 어떻게 R을 설치하나요? (윈도우즈 환경), R의 설치는 어떻게 하나요?
@subsection 어떻게 R을 설치하나요? (Mac)

The @file{bin/macosx} directory of a @CRAN{} site contains a standard Apple
installer package to run on macOS 10.13 (`High Sierra') or later, and
another which runs only on `Apple Silicon' Macs under macOS 11 (`Big Sur')
or later.  Once downloaded and executed, the installer will install the
current release of R and R.app, the macOS @acronym{GUI}.  This port of R for
macOS is maintained by @email{Simon.Urbanek@@R-project.org, Simon Urbanek}
(and previously by Stefano Iacus).  The
@url{https://CRAN.R-project.org/bin/macosx/RMacOSX-FAQ.html, ``R for macOS
@acronym{FAQ}''} has more details.

Snapshots of the r-patched and r-devel versions of R are available as Apple
installer packages at @uref{https://mac.R-project.org}.

@node R을 유닉스와 같은 환경에서 사용할 수 있도록 바이너리 파일이 제공되나요?, What documentation exists for R?, R의 설치는 어떻게 하나요?, R 기초
@section R을 유닉스와 같은 환경에서 사용할 수 있도록 바이너리 파일이 제공되나요?

@c Linux binaries as of 2014-07-27:
@c Providers:
@c   Debian: Johannes Ranke <jranke@uni-bremen.de>
@c   Ubuntu: Michael Rutter <mar36@psu.edu>
@c
@c debian
@c   current:
@c     wheezy-cran3     i386/amd64/armel        3.1.1
@c     squeeze-cran3    i386/amd64              3.1.1
@c   archive:
@c     squeeze-cran     i386/amd64              2.15.3
@c     lenny-cran       i386/amd64              2.14.1
@c     etch-cran        i386/amd64              2.11.0
@c   
@c ubuntu
@c   Trusty Tahr (14.04)
@c   Saucy Salamander (13.10)
@c   Quantal Quetzal (12.10)
@c   Precise Pangolin (12.04; LTS)
@c   Lucid Lynx (10.04; LTS)

Binary distributions of R are available on many Unix-like OSes: only some
can be mentioned here so check your OS's search facilities to see if one is
available for yours.

@CRAN{} 사이트의 @file{bin/linux} 디렉터리는 다음과 같은 패키지들을 담고있습니다.

@need 1000
@quotation
@multitable {Red Hat} {i386/x86_64} {lucid/precise/trusty} {Martyn Plummer}
@headitem @tab CPU @tab Versions @tab Provider
@item Debian   @tab i386/amd64  @tab squeeze/wheezy       @tab Johannes Ranke
@item @tab armel       @tab wheezy               @tab Johannes Ranke
@item Ubuntu   @tab i386/amd64  @tab lucid/precise/trusty @tab Michael Rutter
@end multitable
@end quotation

Debian packages, maintained by Dirk Eddelbuettel, have long been part of the
Debian distribution, and can be accessed through APT, the Debian package
maintenance tool.  Use e.g.@: @code{apt-get install r-base r-recommended} to
install the R environment and recommended packages.  If you also want to
build R packages from source, also run @code{apt-get install r-base-dev} to
obtain the additional tools required for this.  So-called ``backports'' of
the current R packages for at least the @dfn{stable} distribution of Debian
are provided by Johannes Ranke, and available from @CRAN{}.  See
@url{https://CRAN.R-project.org/bin/linux/debian/index.html} for details on
R Debian packages and installing the backports, which should also be
suitable for other Debian derivatives.  Native backports for Ubuntu are
provided by Michael Rutter.

R binaries for Fedora, maintained by Tom ``Spot'' Callaway, are provided as
part of the Fedora distribution and can be accessed through @command{yum},
the RPM installer/updater.  Note that the ``Software'' application
(gnome-software), which is the default @acronym{GUI} for software
installation in Fedora 20, cannot be used to install R.  It is therefore
recommended to use the yum command line tool.  The Fedora R RPM is a
``meta-package'' which installs all the user and developer components of R
(available separately as @code{R-core} and @code{R-devel}), as well as
@code{R-java}, which ensures that R is configured for use with Java.  The R
RPM also installs the standalone R math library (@code{libRmath} and
@code{libRmath-devel}), although this is not necessary to use R.  When a new
version of R is released, there may be a delay of up to 2 weeks until the
Fedora RPM becomes publicly available, as it must pass through the Fedora
review process.  RPMs for a selection of R packages are also provided by
Fedora.  The Extra Packages for Enterprise Linux (EPEL) project
(@url{https://docs.fedoraproject.org/en-US/epel/}) provides ports of the
Fedora RPMs for RedHat Enterprise Linux and compatible distributions (e.g.,
Centos, Scientific Linux, Oracle Linux).

See @url{https://CRAN.R-project.org/bin/linux/suse/README.html} for
information about RPMs for openSUSE.

No other binary distributions are currently publicly available via @CRAN{}.

@node What documentation exists for R?, R을 인용하는 방법, R을 유닉스와 같은 환경에서 사용할 수 있도록 바이너리 파일이 제공되나요?, R 기초
@section What documentation exists for R?

Online documentation for most of the functions and variables in R exists,
and can be printed on-screen by typing @kbd{help(@var{name})} (or
@kbd{?@var{name}}) at the R prompt, where @var{name} is the name of the
topic help is sought for.  (In the case of unary and binary operators and
control-flow special forms, the name may need to be quoted.)

This documentation can also be made available as one reference manual for
on-line reading in @HTML{} and PDF formats, and as hardcopy via @LaTeX{},
see @ref{How can R be installed?}.  An up-to-date @HTML{} version is always
available for web browsing at @url{https://stat.ethz.ch/R-manual/}.

@c Printed copies of the R reference manual for some version(s) are
@c available from Network Theory Ltd, at
@c @c https: is untrusted
@c @url{http://www.network-theory.co.uk/R/base/}.  For each set of manuals
@c sold, the publisher donates USD 10 to the R Foundation (@pxref{What is
@c the R Foundation?}).

R은 다음과 같은 매뉴얼들과 함께 배포되고 있습니다.

@itemize @bullet
@item ``An Introduction to R'' (@file{R-intro})
는 데이터의 유형, 프로그래밍 구성요소들, 통계 모델링과 그래픽스에 대한 정보를 포함하고 있습니다. 이 문서는 Bill Venables과
David Smith가 작성한 ``Notes on S-Plus''라는 문서를 토대로 하고 있습니다.
@item ``Writing R Extensions'' (@file{R-exts})
는 R 애드온(add-on) 패키지의 작성절차, R 문서 작성요령, R과 다른 언어들과의 인터페이스, 그리고 @acronym{API}에
대해서 기술하고 있습니다.
@item ``R Data Import/Export'' (@file{R-data})
는 데이터 입출력에 대한 가이드입니다.
@item ``The R Language Definition'' (@file{R-lang}),
는 ``Kernighan & Ritchie of R''이라는 문서의 최초 버전이기도 하며, 이밸류에이션(evaluation, 평가,
파싱(parsing, 구문해석), 객체지향 프로그래밍 (object oriented programming), 연산(computing)
등의 내용을 다루고 있습니다.
@item ``R Installation and Administration'' (@file{R-admin}).
@item ``R Internals'' (@file{R-ints})
R의 내부구조(internal structure)에 대한 가이드입니다 (R-2.4.0에서 추가되었습니다).
@end itemize

R과 관련된 문헌(publications)들에 대한 정보는 Bib@TeX{} 형식으로 아래의 주소에서 찾아 볼 수있습니다.

@display
@url{https://www.R-project.org/doc/bib/R.bib}
@end display

R 코어팀 멤버들에 의해서 씌여진 책들은 아래와 같습니다.

@quotation
John M. Chambers (2008), ``Software for Data Analysis: Programming with
R''.  Springer, New York, ISBN 978-0-387-75935-7,
@url{https://statweb.stanford.edu/~jmc4/Rbook/}.

Peter Dalgaard (2008), ``Introductory Statistics with R'', 2nd edition.
Springer, ISBN 978-0-387-79053-4,
@url{http://publicifsv.sund.ku.dk/~pd/ISwR.html}.

Robert Gentleman (2008), ``R Programming for Bioinformatics''.  Chapman &
Hall/CRC, Boca Raton, FL, ISBN 978-1-420-06367-7,
@url{https://master.bioconductor.org/help/publications/books/r-programming-for-bioinformatics/}.

Stefano M. Iacus (2008), ``Simulation and Inference for Stochastic
Differential Equations: With R Examples''. Springer, New York, ISBN
978-0-387-75838-1.

Deepayan Sarkar (2007), ``Lattice: Multivariate Data Visualization with
R''. Springer, New York, ISBN 978-0-387-75968-5.

W. John Braun and Duncan J. Murdoch (2007), ``A First Course in Statistical
Programming with R''.  Cambridge University Press, Cambridge, ISBN
978-0521872652.

P. Murrell (2005), ``R Graphics'', Chapman & Hall/CRC, ISBN: 1-584-88486-X,
@url{https://www.stat.auckland.ac.nz/~paul/RGraphics/rgraphics.html}.

William N. Venables and Brian D. Ripley (2002), ``Modern Applied Statistics
with S'' (4th edition).  Springer, ISBN 0-387-95457-0,
@url{https://www.stats.ox.ac.uk/pub/MASS4/}.

Jose C. Pinheiro and Douglas M. Bates (2000), ``Mixed-Effects Models in S
and S-Plus''. Springer, ISBN 0-387-98957-0.
@end quotation

Last, but not least, Ross' and Robert's experience in designing and
implementing R is described in Ihaka & Gentleman (1996), ``R: A Language for
Data Analysis and Graphics'', @emph{Journal of Computational and Graphical
Statistics}, @strong{5}, 299--314 (@doi{10.1080/10618600.1996.10474713}).

@node R을 인용하는 방법, R과 관련하여 어떤 메일링 리스트들이 있나요?, What documentation exists for R?, R 기초
@section R을 인용하는 방법

R을 참고자료로서 인용하고자 한다면, 아래의 Bib@TeX{}를 이용하시면 됩니다.

@example
@group
@@Manual@{,
  title        = @{R: A Language and Environment for Statistical
                  Computing@},
  author       = @{@{R Core Team@}@},
  organization = @{R Foundation for Statistical Computing@},
  address      = @{Vienna, Austria@},
  year         = @var{YEAR},
  url          = @{https://www.R-project.org@}
@}
@end group
@end example
@noindent
where @var{YEAR} is the release year of the version of R used and can
determined as @code{R.version$year}.

R과 R 패키지들에 대한 Bib@TeX{} 항목들또는 인용정보들은 @code{citation()}을 통하여 얻을 수 있습니다.

@node R과 관련하여 어떤 메일링 리스트들이 있나요?, CRAN이란 무엇인가요?, R을 인용하는 방법, R 기초
@section R과 관련하여 어떤 메일링 리스트들이 있나요?

Thanks to @email{Martin.Maechler@@R-project.org, Martin Maechler}, there are
several mailing lists devoted to R, including the following:

@table @code
@item R-announce
는 R의 개발과 새로운 코드의 유용성에 관한 주요 공지사항들을 위한 (moderated) 리스트입니다.
@item R-packages
는 새롭게 개발되거나 주요기능들이 강화된 패키지들의 유용성에 대한 공지사항들을 위한 (moderated) 리스트입니다.
@item R-help
@c about the development of R and the availability of new code.
@c enhancements and patches to the source code and documentation of R,
@c comparison and compatibility with S and @SPLUS{}, and for the posting of
@c nice examples and benchmarks.
The `main' R mailing list, for discussion about problems and solutions
encountered using R, including using R packages in the standard R
distribution and on CRAN; announcements (not covered by `R-announce' or
`R-packages'); the availability of new functionality for R and documentation
of R; and for posting nice examples and benchmarks. 
@item R-devel
@c discussions about the future of R, proposals of new functionality, and
@c pre-testing of new versions.  It is meant for those who maintain an
@c active position in the development of R.
는 R의 코드개발 (code development)에 관한 질문들과 논의를 위한 리스트입니다.  R의 미래에 대한 논의, 새로운 기능에
대한 제안, 그리고 새로운 버전에 대한 테스트를 목적으로 이용될 수 있습니다.  이 리스트는 R의 개발에 적극적인 자세 (active
position)을 유지하는 사람을 위한 것입니다.
@item R-package-devel
A list which provides a forum for those developing R packages.
@end table

@noindent
Please read the @url{https://www.R-project.org/posting-guide.html, posting
guide} @emph{before} sending anything to any mailing list.

R-help 는 본래 R을 이용하여 본인의 문제를 해결하고자 하지만 프로그래밍에 대한 지식이 부족한 분들을 위해서 개설되었다는 것을
아셨으면 합니다. 따라서, 프로그래머가 아닌 사람들이 이해하기 어려운 질문들 (즉, C 혹은 C++ 과 연관된 내용)은 R-devel을
이용하시길 부탁드립니다.  

Convenient access to information on these lists, subscription, and archives
is provided by the web interface at
@url{https://stat.ethz.ch/mailman/listinfo/}.  One can also subscribe (or
unsubscribe) via email, e.g.@: to R-help by sending @samp{subscribe} (or
@samp{unsubscribe}) in the @emph{body} of the message (not in the subject!)
to @email{R-help-request@@lists.R-project.org}.

R-help 메일링 리스트를 구독하는 모든 이들에게 메시지를 보내기 위해서는
@email{R-help@@lists.R-project.org}로 이메일을 보내주세요. 다른 메일링 리스트들의 구독 및 포스팅 요령은
r-help와 동일합니다.  @samp{R-help} 대신에 @samp{R-announce}, @samp{R-packages},
@samp{R-devel} 이라고만 변경해주시면 됩니다. R-announce과 R-packages는 R-help에 이르는 과정이라는 점을
아시길 바랍니다.  만약 R-help를 구독하고 있지 않다면 둘 중 어느 하나는 구독을 해야합니다.

@strong{사용자가 R 코어 개발자들에게 개별적으로 이메일을 보내기 보다는 R-help에 메일을 보내주시길 부탁드립니다 (코어 멤버들
역시 메일링을 사용하고 있습니다)}.  이러한 부탁을 하는 이유는 코어 개발자들이 지속적으로 R을 향상시키는데 있어서 많은 시간을
줄여주기도 할 뿐더러, 질문자가 가장 빠른 시간내에 답변을 받을 수 있기 때문입니다. 

버그리포트를 할 때에는 버그를 정확하게 재구현할 수 있도록 코드를 함께 올려주시면 매우 도움이 됩니다.  또한, 이러한 버그를 보고할 때
사용자가 어떤 시스템과 어떤 버전의 R 을 사용하는지 알려주시길 부탁드립니다. 더 자세한 사항들에 대해서는 @ref{R
버그(Bugs)}를 살펴보세요.

See @url{https://www.R-project.org/mail.html} for more information on the R
mailing lists.

@c >> No longer want such comments and reports addressed to R-core :
@c The R Core Team can be reached at @email{R-core@@lists.R-project.org}
@c for comments and reports.

@c <FIXME>
@c As of 2017-10, accessing GMANE's gmane.comp.lang.r still says
@c   Not all of Gmane is back yet ...
@c Hence comment out for the time being.
@c Many of the R project's mailing lists are also available via
@c @url{http://gmane.org, Gmane}, from which they can be read with a web
@c browser, using an NNTP news reader, or via RSS feeds.  See
@c @uref{http://dir.gmane.org/index.php?prefix=gmane.comp.lang.r.}@: for
@c the available mailing lists, and @uref{http://www.gmane.org/rss.php} for
@c details on RSS feeds.
@c </FIXME>

@node CRAN이란 무엇인가요?, R을 상업적 용도로 사용할 수 있나요?, R과 관련하여 어떤 메일링 리스트들이 있나요?, R 기초
@section @acronym{CRAN}이란 무엇인가요?

``Comprehensive R Archive Network'' (@CRAN{})은 R 배포판, 기여된 확장 프로그램들 (즉,
패키지들), R과 관련된 문서들, 그리고 바이너리들로 구성되어 있는 동일한 자료들을 전달하는 사이트들의 모음을 의미합니다.

The @CRAN{} main site at WU (Wirtschaftsuniversit@"at Wien) in Austria can
be found at the @acronym{URL}

@quotation
@c @multitable @columnfractions .45 .30
@c @item
@c @tab (Austria)
@c @end multitable
@url{https://CRAN.R-project.org/}
@end quotation

@noindent
and is mirrored daily to many sites around the world.  See
@url{https://CRAN.R-project.org/mirrors.html} for a complete list of
mirrors.  Please use the @CRAN{} site closest to you to reduce network load.

From @CRAN{}, you can obtain the latest official release of R, daily
snapshots of R (copies of the current source trees), as gzipped and bzipped
tar files, a wealth of additional contributed code, as well as prebuilt
binaries for various operating systems (Linux, Mac OS Classic, macOS, and MS
Windows).  @CRAN{} also provides access to documentation on R, existing
mailing lists and the R Bug Tracking system.

Since March 2016, ``old'' material is made available from a central @CRAN{}
archive server (@url{https://CRAN-archive.R-project.org/}).

@CRAN{} 을 참조할때는 항상 마스터 사이트의 @acronym{URL}  을 사용해주시기 바랍니다.

@node R을 상업적 용도로 사용할 수 있나요?, 왜 R이라고 이름을 짓게 되었나요?, CRAN이란 무엇인가요?, R 기초
@section R을 상업적 용도로 사용할 수 있나요?

R is released under the
@url{https://www.gnu.org/licenses/old-licenses/gpl-2.0.html,, @acronym{GNU}
General Public License (@acronym{GPL}), version 2 or version 3}.  If you
have any questions regarding the legality of using R in any particular
situation you should bring it up with your legal counsel.  We are in no
position to offer legal advice.

It is the opinion of the R Core Team that one can use R for commercial
purposes (e.g., in business or in consulting).  The @acronym{GPL}, like all
Open Source licenses, permits all and any use of the package.  It only
restricts distribution of R or of other programs containing code from R.
This is made clear in clause 6 (``No Discrimination Against Fields of
Endeavor'') of the @url{https://opensource.org/docs/definition.html, Open
Source Definition}:

@quotation
라이센스는 어느 특정 분야에서 이 프로그램이 사용되는것을 누구에게라도 제한해서는 않됩니다. 예를 들어, 이 프로그램이 유전자 연구나 어느
사업에서 사용되는 것을 제한 할 수없습니다.

@emph{The license must not restrict anyone from making use of the program in
a specific field of endeavor.  For example, it may not restrict the program
from being used in a business, or from being used for genetic research.}
@end quotation

@noindent
이는 또한 GPL 제 0항 (clause 0)에서도 아래와 같이 (일부분만) 언급되어 있습니다. 

@quotation
복사, 배포 및 수정 이외의 활동은 본 라이센스에 포함되지 않습니다; 그런 활동들은 본 라이센스의 범위를 벗어난 활동들입니다. 프로그램을
실행시키는 행위는 제한되지 않습니다. 그리고, 프로그램의 출력물은 그 내용이 프로그램에 기초한 저작물을 구성하는 경우에만 포함됩니다.
@end quotation

모든 추천(recommended) 패키지들을 포함하여 대부분의 애드온(add-on) 패키지들은 이러한 방법으로서 상업적으로도 이용이 될
수 있음을 명시하고 있습니다.  몇개의 패키지들은 ``non-commercial use''(비상업용적 용도)로서 제한됩니다.  이 경우
사용자는 반드시 저작권자에게 상업적 용도로의 활용여부를 문의하거나 법률상담가로부터의 조언을 찾아야 합니다.

이 섹션에 언급된 모든 논의는 법적조언이 아닙니다. R Core Team은 어떠한 경우에도 법적조언을 제공하지 않습니다.

@node 왜 R이라고 이름을 짓게 되었나요?, R 재단(Foundation)은 무엇을 말하나요?, R을 상업적 용도로 사용할 수 있나요?, R 기초
@section 왜 R이라고 이름을 짓게 되었나요?

R이라는 이름은 R을 최초로 개발한 두 개발자인 Robert Gentleman과 Ross Ihaka의 이름에서 기인하기도 하며, 동시에
Bell 연구소의 'S' 라는 언어에서 영감을 받기도 하였습니다 (@pxref{S란 무엇인가요?} 섹션을 참고하세요).

@c At the time the name was coined no one expected that the software would
@c get used outside of Auckland, so it seemed ok to make a joke of it.

@node R 재단(Foundation)은 무엇을 말하나요?, R-Forge는 무엇인가요?, 왜 R이라고 이름을 짓게 되었나요?, R 기초
@section R 재단(Foundation)은 무엇을 말하나요?

The R Foundation is a not for profit organization working in the public
interest.  It was founded by the members of the R Core Team in order to
provide support for the R project and other innovations in statistical
computing, provide a reference point for individuals, institutions or
commercial enterprises that want to support or interact with the R
development community, and to hold and administer the copyright of R
software and documentation.  See @url{https://www.R-project.org/foundation/}
for more information.

@node R-Forge는 무엇인가요?, , R 재단(Foundation)은 무엇을 말하나요?, R 기초
@section R-Forge는 무엇인가요?

R-Forge (@url{https://R-Forge.R-project.org/}) offers a central platform for
the development of R packages, R-related software and further projects.  It
is based on @url{https://en.wikipedia.org/wiki/GForge, GForge} offering easy
access to the best in SVN, daily built and checked packages, mailing lists,
bug tracking, message boards/forums, site hosting, permanent file archival,
full backups, and total web-based administration.  For more information, see
the R-Forge web page and Stefan Theu@ss{}l and Achim Zeileis (2009),
``Collaborative software development using R-Forge'',
@url{https://journal.R-project.org/, , @emph{The R Journal}},
@strong{1}(1):9--14.


@node R과 S, R 웹인터페이스(Web Interfaces), R 기초, Top
@chapter R과 S

@menu
* S란 무엇인가요?::
* S-PLUS란 무엇인가요?::
* R과 S 사이에 다른 점이 있나요?::
* R은 할 수 있지만 S-PLUS는 할 수 없는 것들이 있나요?::
* R-plus란 무엇인가요?::  
@end menu

@node S란 무엇인가요?, S-PLUS란 무엇인가요?, R과 S, R과 S
@section S란 무엇인가요?

S는 데이터 분석과 그래픽스를 위한 하이레벨 언어 (high level language)이며 환경입니다. 1998년에
Association for Computing Machinery (@acronym{ACM})는 1998년에 S언어의 주요설계자인 John
M. Chambers에게 아래와 같이 치하하며 Software System Award를 수여하였습니다.

@quotation
S 시스템은 영원히 사람들이 데이터를 분석, 시각화 그리고 조작하는 방법을 변화시켰다 @dots{}

@emph{the S system, which has forever altered the way people analyze,
visualize, and manipulate data @dots{}}

John Chambers 의 고마운 통찰력, 풍취와 노력으로 만들어진 S 는 훌륭하고, 널리 인정 받으며 개념적으로 완전한 지속적인
소프트웨어 시스템 입니다. 
@end quotation

S 언어의 발전은 John Chambers와 공동저자들에 의하여 쓰여진 네권의 책들에 잘 설명되어 있습니다.  이들은 또한 S에 대한
주요 참고문헌이기도 합니다.

@itemize @bullet
@item
Richard A. Becker and John M. Chambers (1984), ``S.  An Interactive
Environment for Data Analysis and Graphics,'' Monterey: Wadsworth and
Brooks/Cole.

이 책은 ``@emph{Brown Book}''(브라운 북)이라고도 알려져 있으며, 역사적 관심으로서입니다.

@item
Richard A. Becker, John M. Chambers and Allan R. Wilks (1988), ``The New S
Language,'' London: Chapman & Hall.

이 책은 ``@emph{Blue Book}''(블루 북)이라고도 하며, S 버전 2로 알려진 것이 무엇인지를 소개합니다.

@item
John M. Chambers and Trevor J. Hastie (1992), ``Statistical Models in S,''
London: Chapman & Hall.

이 책은 @emph{White Book}라고도 하며, S에서 통계모델링(statistical modeling)의 기능을 수행하기 위한
구조들이 추가되어진 S 버전 3로 알려진 것을 소개합니다. 

@item
John M. Chambers (1998), ``Programming with Data,'' New York: Springer, ISBN
0-387-98503-4 (@url{https://statweb.stanford.edu/~jmc4/Sbook/}).

``@emph{Green Book}''(그린 북)은 프로그래밍 프로세스의 매 단계마다 유용성을 향상시킬 수 있도록 John
Chambers에 의하여 설계된 S의 주요수정사항들이 있는 S 버전 4를 설명합니다.
@end itemize

See @url{https://statweb.stanford.edu/~jmc4/papers/96.7.ps} for further
information on the ``Evolution of the S Language''.

@c There is a huge amount of user-contributed code for S, available at the
@c @url{http://lib.stat.cmu.edu/S/, S Repository} at @acronym{CMU}.

@c The @url{http://lib.stat.cmu.edu/S/faq, ``Frequently Asked Questions
@c about S''} contains further information about S, but is not
@c up-to-date.

@node S-PLUS란 무엇인가요?, R과 S 사이에 다른 점이 있나요?, S란 무엇인가요?, R과 S
@section @sc{S-Plus}란 무엇인가요?

@SPLUS{} is a value-added version of S sold by @url{https://www.tibco.com/,
TIBCO Software Inc} as `TIBCO Spotfire S+'.  See
@url{https://en.wikipedia.org/wiki/S-PLUS} for more information.

@node R과 S 사이에 다른 점이 있나요?, R은 할 수 있지만 S-PLUS는 할 수 없는 것들이 있나요?, S-PLUS란 무엇인가요?, R과 S
@section R과 S 사이에 다른 점이 있나요?

S는 현재 세가지 종류의 구현체 또는 ``engines''(엔진)을 가진 언어로서 여길 수 있습니다.  이는 ``old S
engine'' (S version 3; S-Plus 3.x 그리고 4.x), ``new S engine'' (S version 4;
S-Plus 5.x 혹은 그 이후의 버전), 그리고 R입니다.  이러한 내용을 바탕으로 보면, ``R과 S 사이의 다른점''에 대한
질문은 S언어를 이용하여 구현된 R의 세부사항들을 묻는것과 같습니다. 즉, R의 엔진과 S의 엔진 사이에 다른 점입니다.

이 섹션에서 이 지점 이후로, "S'' 는 S 엔진이 아닌 S 언어를 의미합니다.

@menu
* 렉시컬 스코핑(lexical scoping)::
* 개발에 영향을 준 모델들(models)::
* 그 밖에::               
@end menu

@node 렉시컬 스코핑(lexical scoping), 개발에 영향을 준 모델들(models), R과 S 사이에 다른 점이 있나요?, R과 S 사이에 다른 점이 있나요?
@subsection 렉시컬 스코핑(lexical scoping)

S언어를 이용한 다른 구현체들과는 다르게 R은 내포된 함수 정의들(nested function definitions)이 렉시컬
스코프(lexically scoped)된 평가모델(evaluation model)을 사용합니다.  이것은 Scheme의 평가모델과
유사합니다.

이 차이점은 함수(function)내에서 @emph{free}(자유)변수들이 발생할때 분명해집니다. 자유변수들은 함수의 인자목록에서
사용된 형식인자(formal argument)도 아니고, 함수의 본체에서 이들에 할당함으로서 생성된 지역변수(local
variables)도 아닙니다. S에서는 자유변수들은 C와 유사하게 전역변수(global variable)들의 묶음에 의해서 결정되어
집니다.  (C에서는 지역적 범위와 전역적 범위만이 있습니다).  R에서 이들은 함수가 생성되어진 환경(environment)에 의해서
결정되어집니다.

다음의 함수를 보십시오:

@example
@group
cube <- function(n) @{
  sq <- function() n * n
  n * sq()
@}
@end group
@end example

S에서, @code{sq()}는 변수 @code{n}이 전역적으로 정의되지 않는 이상은 이에 대해서 알지 못합니다:

@example
@group
S> cube(2)
Error in sq():  Object "n" not found
Dumped
S> n <- 3
S> cube(2)
[1] 18
@end group
@end example

R에서는 @code{cube()}가 실행되었을때 생성된 ``environment''(환경)이 살펴지게 됩니다:

@example
@group
R> cube(2)
[1] 8
@end group
@end example

@c The following more `realistic' example illustrating the differences in
@c scoping is due to @email{tlumley@@u.washington.edu, Thomas Lumley}.
@c The function

@c @example
@c jackknife.lm <- function(lmobj) @{
@c   n <- length(resid(lmobj))
@c   jval <- sapply(1:n, function(i) coef(update(lmobj, subset = -i)))
@c   (n - 1) * (n - 1) * var(jval) / n
@c @}
@c @end example

@c @noindent
@c does something useful in R, but does not work in S.  In order to make it
@c work in S you need to explicitly pass the linear model object into the
@c function nested in @code{apply()}.  If you don't and you are lucky you
@c will get @samp{Error: Object "lmobj" not found}.  If you are unlucky
@c enough to have a linear model called @code{lmobj} in your global
@c environment you will get the wrong answer with no warning.

@c The following version works in S.

@c @example
@c jackknife.S.lm <- function(lmobj) @{
@c   n <- length(resid(lmobj))
@c   jval <- sapply(1:n,
@c                  function(i, lmobj) coef(update(lmobj, subset = -i)), 
@c                  lmobj = lmobj)
@c   (n - 1) * (n - 1) * var(jval) / n
@c @}
@c @end example

@c (The S version was written independently by Thomas and at least three of
@c his fellow students over the past couple of years, causing literally
@c hours of confusion on each occasion.)

실제로 다루어 볼 수 있는 흥미로운 문제로서, (연속)분포에서 샘플의 크기 @math{n}으로부터 @math{r} 번째의 order
statistic (순서통계량)의 밀도함수를 구하는 함수를 작성해본다고 가정해 봅니다.  단순한 방법으로 우리는 분포의 cdf와 pdf
모두를 explicit arguments(명시적 인자들)로 사용해야 합니다.  (이는 Luke Tierney에 의하여 작성된 다양한
포스팅으로부터 뽑아낸 예제입니다).

@code{call()}에 대한 @SPLUS{} 문서는 기본적으로 다음과 같이 하도록 안내합니다.

@example
@group
dorder <- function(n, r, pfun, dfun) @{
  f <- function(x) NULL
  con <- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
  PF <- call(substitute(pfun), as.name("x"))
  DF <- call(substitute(dfun), as.name("x"))
  f[[length(f)]] <-
    call("*", con,
         call("*", call("^", PF, r - 1),
              call("*", call("^", call("-", 1, PF), n - r),
                   DF)))
  f
@}
@end group
@end example

@noindent Rather tricky, isn't it?  The code uses the fact that in S,
이 코드는 S에서는 함수들이 마지막 인자와 같이 함수의 본체의 특정한 방식(mode)의 목록들이라는 사실을 이용하고 있습니다.  이러한
방식은 R에서 작동하지 않습니다 (누군가는 여기에서 사용된 아이디어를 성공적으로 구현할 수도 있을것입니다).

@code{substitute()}의 사용빈도가 매우 높으며 S와 R 모두 작동하는 것처럼 보이는 버전은 다음과 같습니다. 

@example
@group
dorder <- function(n, r, pfun, dfun) @{
  con <- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
  eval(substitute(function(x) K * PF(x)^a * (1 - PF(x))^b * DF(x),
                  list(PF = substitute(pfun), DF = substitute(dfun),
                       a = r - 1, b = n - r, K = con)))
@}
@end group
@end example

@noindent
(S에서는 @code{eval()}이 필요하지 않습니다).

그러나, R에서는 다음과 같은 더욱 쉬운 해결책이 있습니다:

@example
@group
dorder <- function(n, r, pfun, dfun) @{
  con <- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
  function(x) @{
    con * pfun(x)^(r - 1) * (1 - pfun(x))^(n - r) * dfun(x)
  @}
@}
@end group
@end example

@noindent
이것은 ``natural(자연스러운)'' 구현 같이 보이며, 귀환된 함수(returned function)내에 있는 자유변수(free
variable)들이 환경을 규정한 내부에서 찾아질 수 있기 때문에 잘 실행됩니다 (이것을 렉시컬 스코프(lexical scope)라고
합니다). 

꼭 알아야 할 것은 함수 @emph{closure}라는 것입니다. 즉, 함수를 평가하기 위하여 필요한 모든 variable
binding(변수 바인딩)들 있는 본체를 의미합니다.  위의 버전의 경우, 값을 지닌 함수내의 자유변수들은 변경되지 않았기 때문에
S에서 이를 사용할 수 있을 뿐아니라, 만약 클로저 작동 (closure operation)을 함수 @code{MC()}로 이끌어 내고자
한다면 (클로져를 만들기 위해서) 다음과 같이 할 수 있습니다. 

@example
@group
dorder <- function(n, r, pfun, dfun) @{
  con <- round(exp(lgamma(n + 1) - lgamma(r) - lgamma(n - r + 1)))
  MC(function(x) @{
       con * pfun(x)^(r - 1) * (1 - pfun(x))^(n - r) * dfun(x)
     @},
     list(con = con, pfun = pfun, dfun = dfun, r = r, n = n))
@}
@end group
@end example

적절한 클로져 연산자(closure operator)의 정의가 주어진다면 이것은 R과 S에서 모두 작동하며 substitute/eval을
활용한 것 (혹은 기본 스코핑 규칙(default scoping rule)을 평가 프레임(evaluation frame)에 대한 명시적
접근(explicit access)을 이용하여 무효화 하는 해결책, 물론 R과 S 모두 가능한) 보다 말끔한 해결책이라고 할 수
있습니다.

R에서는 @code{MC()}는 단순히 아래와 같습니다.

@example
MC <- function(f, env) f
@end example

@noindent (lexical scope!), a version for S is

@example
@group
MC <- function(f, env = NULL) @{
  env <- as.list(env)
  if (mode(f) != "function")
    stop(paste("not a function:", f))
  if (length(env) > 0 && any(names(env) == ""))
    stop(paste("not all arguments are named:", env))
  fargs <- if(length(f) > 1) f[1:(length(f) - 1)] else NULL
  fargs <- c(fargs, env)
  if (any(duplicated(names(fargs))))
    stop(paste("duplicated arguments:", paste(names(fargs)),
         collapse = ", "))
  fbody <- f[length(f)]
  cf <- c(fargs, fbody)
  mode(cf) <- "function"
  return(cf)
@}
@end group
@end example

유사하게 대부분의 최적화 (optimization 또는 zero-finding) 루틴(rountine)들은 최적화 되어야 할 일부
인자들이 필요하며, 데이터에 의존하지만 최적화와 관련해서는 영향을 미치지 않는 다른 인자들을 가집니다.  이것은 R 스코핑
규칙(scoping rules)을 이용하면 단순하게 같은 환경내에서 필요한 정의들만을 가지고 함수를 만들게 되면 나머지는 스코핑이 알아서
처리하게 되므로 매우 간단한 문제입니다.  S를 이용한 한가지 방법은 별도의 인자(extra parameter)를 함수와 이러한 별도의
인자들이 넘겨지게 될 옵티마이저(optimizer)에 추가하는 것이지만, 이는 오로지 옵티마이저가 지원될 경우에만 가능합니다.

Nested lexically scoped functions allow using function closures and
maintaining local state.  A simple example (taken from Abelson and Sussman)
is obtained by typing @kbd{demo("scoping")} at the R prompt.  Further
information is provided in the standard R reference ``R: A Language for Data
Analysis and Graphics'' (@pxref{What documentation exists for R?}) and in
Robert Gentleman and Ross Ihaka (2000), ``Lexical Scope and Statistical
Computing'', @emph{Journal of Computational and Graphical Statistics},
@strong{9}, 491--508 (@doi{10.1080/10618600.2000.10474895}).

중첩된 구조의 렉시컬 스코프를 따르는 함수들 (nested lexically scoped functions)은 더 중요한 다른 점을
의미합니다. S는 모든 객체들을 디렉토리의 어딘가에 (보통은 현재 디렉토리내에  @file{.Data}의 형식으로) 각각 다른 파일들로
저장하는 반면, R은 그러하지 않습니다.  R의 모든 객체들은 내부적으로 저장됩니다.  R이 실행되었을때, R은 메모리(memory)의
한 조각을 붙잡고 이를 객체를 저장하는데 사용합니다. R은 이러한 메모리 사용을 위한 메모리 관리기능(memory management)을
수행하고, 필요한 만큼의 크기를 늘이고 줄이게 됩니다.  심볼과 값들간의 바인딩(symbol/value pairs)에 관련된 모든
``환경(environments)''를 외부에서 유지하는 것은 거의 가능하지 않기 때문에 모든 것을 메모리내에서 관리할 필요가
있습니다. 이러한 차이 또한 R이 S보다 빠른 것 처럼 보이게 합니다. 

다소 불편한 점이 있다면 R이 크래쉬(crash)되면 현재 세션에서 작업하는 모든 것을 잃게 됩니다.  메모리를 저장하고 복원하는
``images''(이미지라는 것은 R의 내부 메모리에 항시 저장되는 함수들과 데이터를 의미합니다)의 크기가 크다면 다소 느릴 수
있습니다.  S에서는 이와 같은 일이 발생하지 않습니다.  그 이유는 모든것이 디스크 파일의 형식으로 저장되기 때문입니다  (누군가는 S
개발자들이 렉시컬 스코프을 위한 공간을 제공하는 것이 지속적인 저장방식을 사용하는 것보다 더 많은 비용이 들것이라고 느꼈을 것이라고
추측할 수도 있습니다).   그래서, 중요한 작업을 할때에는 가능한 크래쉬(crash)들로부터 보호하기 위해서 자주 저장하는 것을 생각해
볼 수 있습니다 (@ref{작업공간을 어떻게 저장할 수 있나요?}를 살펴보세요).  또 다른 방법으로는 세션(session)을
기록(logging)하거나, @code{source()}를 이용하여 읽어들일 수 있는 텍스트 파일에 저장된 R 명령어들을 가지는
것입니다.

@quotation Note
만약 R을 Emacs내에서 실행한다면 (@ref{R과 이맥스(Emacs)}을 살펴보세요), 인터랙션버퍼(interaction
buffer)안의 내용들(contents)를 파일에 저장하고 이들을 @code{ess-transcript-mode}를 이용하여 쉽게
조작할 수 있으며, 사용된 모든 함수와 데이터들의 원시복제(source copy)를 저장할 수 있습니다.
@end quotation

@node 개발에 영향을 준 모델들(models), 그 밖에, 렉시컬 스코핑(lexical scoping), R과 S 사이에 다른 점이 있나요?
@subsection 개발에 영향을 준 모델들(models)

모델링 코드(modeling code)에는 아래와 같이 몇가지 다른 점들을 볼 수 있습니다.

@itemize @bullet
@item
S에서는 @code{y}를 @code{x^3}을 이용하여 회귀(regress)하기 위해서는 @code{lm(y ~ x^3)}를 사용하는
반면, R에서는 수치벡터의 자승부분을 @code{I()}를 이용하여 따로 보호처리를 해야합니다.  즉, @code{lm(y ~
I(x^3))}이라고 사용해야 합니다.
@item
일반선형화모델 페밀리 객체들(glm family objects)는 R과 S에서 다르게 구현되어 있습니다.  같은 기능을 이용할 수
있으나, 구성요소들은 서로 다른 이름들을 가지고 있습니다.
@item
@code{na.action}이라는 옵션은 @code{"na.omit"}이라는 값으로 R에서는 기본적으로 설정되어 있으나, S에서는
그렇지 않습니다.
@item
항 객체(terms objects)들은 다른 방식으로 저장됩니다.  S에서는 항 객체(terms objects)은
속성(attributes)와 함께 이용된 표현식(expression)이지만, R에서는 속성과 함께 이용된 formula (공식 또는
포뮬러)입니다.  속성들은 같은 이름들을 가지고 있으나 대부분 다르게 저장됩니다.
@item
마지막으로 절편(intercept)가 없는 모델을 정의하기 위해서 R에서는 @code{y ~ x + 0}이라는 표현은 @code{y ~
x - 1}의 또 다른 표현입니다.  아무런 파라미터들(parameters)를 없는 모델을 @code{y ~ 0}로 표현할 수
있습니다. 
@end itemize

@node 그 밖에, , 개발에 영향을 준 모델들(models), R과 S 사이에 다른 점이 있나요?
@subsection 그 밖에

렉시컬 스코핑(lexical scoping)과 이것의 의미를 떠나서, R은 Blue와 White 책에 있는 S 랭귀지
정의(language definition)을 가능하면 많이 본땄기 때문에 결과적으로는 S를 이용한
``implementation''(구현물)입니다.  S의 작동방식(behaviour)가 ``not clean''(깔끔하지 못하다고)
고려되는 부분들에 있어서는 의도적인 다른 점들을 가지고 있습니다.  일반적 방침은 R은 S와 가능하면 호환될 수 있게 함과 동시에
사용자가 프로그래밍 에러를 찾을수 있게 도와주도록 하는 것입니다. 

몇 가지 알려진 다른 점들을 아래에 설명하였습니다. 

@itemize @bullet

@item
R에서는 만약 @code{x}가 리스트(list)라면 @code{x[i] <- NULL}과 @code{x[[i]] <- NULL}이라고
하는 것은 @code{x}로부터 지정된 구성요소들을 삭제합니다.  이들중 첫번째 표현은 no-op인 곳에서는 S에서 사용할 수
없습니다.  (@code{x[i] <- list(NULL)}을 이용하여 @code{NULL}이라는 구성요소를 지정할 수 있습니다).

@c @item
@c In R @code{x[-4]} fails if @code{x} is not @code{NULL} but has fewer
@c than 4 elements.  In S it has no effect.

@item
S에서, @file{.Data} 디렉토리 내에서 @code{.First}와 @code{.Last}라는 이름을 가진 함수들은 세션의 가장
처음과 마지막에서 실행되기 때문에 커스터마이징(customizing)을 위한 목적으로 사용될 수 있습니다.

R에서 스타트업(startup) 메카니즘은 다음과 같습니다. 만약 명령어 라인에 @option{--no-environ}이 주어지지
않았다면, R은 환경변수들(environment variables)들을 설정하기 위한 사이트와 사용자 파일들(site and user
files)으르 찾습니다.  그리고 나서, 명령어 라인에 @option{--no-site-file}이 주어지지 않았다면, 사이트-와이드
스타트업 프로파일 (site-wide startup profile)을 탐색합니다.  이 코드는 패키지 @pkg{base}에 로드되어
있습니다.  그리고 나서, @option{--no-init-file}이 주어지지 않았다면 R은 사용자 프로파일 파일(user
profile file)을 탐색하고 이를 사용자의 작업공간(user workspace)로 읽어(source)들입니다.  그런 후에, 만약
@option{--no-restore-data} 또는 @option{--no-restore}가 지정되지 않는 이상
@file{.RData}에 사용자 작업공간의 저장된 이미지가 있다면 이를 불러옵니다.  그런 다음, 함수 @code{.First()}가
검색경로(serach path)위에 있다면 실행됩니다.  마지막으로 패키지 @pkg{base} 내에 있는 함수
@code{.First.sys}가 실해됩니다. R 세션을 종료할 때, 만약 @code{.Last}가 검색경로에서 찾아진다면 이를 실행한
뒤에 @option{.Last.sys}가 실행됩니다. 만약 필요하다면 함수들 @code{.First()}와 @code{.Last()}들은
적절한 스타트업 프로파일에 정의되어야 합니다. 더 구체적인 내용은 @code{.First}와 @code{.Last}에 대한 도움말을
참고하세요.

@item
R에서는 @code{T}와 @code{F}는 단순히 @code{TRUE}와 @code{FALSE}로 정해지는 변수들이지만, S에서는
예약어(reserved words)가 아니기 때문에 사용자에 의해서 덮어씌여질 수 있습니다.  (이는 @code{"T"}와
@code{"F"}라는 요인의 수준들을 이용할 때 유용합니다). 그러므로, 코드를 작성할 때 @code{TRUE}와
@code{FALSE}를 항상 이용해야만 합니다. 

@item
R에서, @code{dyn.load()}는 오로지 공유된 객체들(shared objects)만을 불러옵니다. 예를들면, @kbd{R
CMD SHLIB}에 의해 생성된 것들입니다. 

@item
R에서 @code{attach()}는 현재의 리스트들과 데이터프레임들만을 결합하는데 이용되지만 디렉토리에는 적용되지 않습니다.
(실제로는 @code{attach()}는 @code{save()}에 의하여 생성된 R 데이터 파일들을 결합하는데, 이는 S에서 디렉토리를
결합하는 것과 유사합니다). 또한 위치 1(position 1)에서는 결합할 수 없습니다. 

@item
R에서는 카테고리 (categories)라는 개념은 존재하지 않으며, S에서 더 이상 사용을 하지 않기 때문에 앞으로도 존재하지 않을
것입니다.  대신에 요인 (factors)를 이용하시길 바랍니다.

@item
R에서는 @code{For()} 루프는 필요하지 않으므로 지원되지 않습니다. 

@item
R에서는 @code{assign()}은 S에서 인자 @option{where=}를 사용하는 것과는 달리 인자
@option{envir=}를 이용합니다. 

@item
난수발생기(random number generators)가 다르며, 시드(seeds)의 길이가 다릅니다. 

@item
R은 정수형 객체를 C로 패스할 때 S가 @code{long *}를 사용하는 것과 달리 @code{int *}를 이용합니다. 

@item
R은 단정도 (single precision) 저장모드 (storage mode). 그러나, 0.65.1부터는 C/@FORTRAN{}
서브루틴에 접속하는(interface) 단정도가 있습니다.

@item
기본적으로 @code{ls()}는 R에서 현재의 환경(current environment)에 있는 객체들의 이름을 반환하지만, S는
전역환경(global environment)에 있는 객체들의 이름을 반환합니다.  예를들면,

@example
x <- 1; fun <- function() @{y <- 1; ls()@}
@end example

@noindent
@code{fun()}은 R에서는 @code{"y"}를 반환하고 S에서는 @code{"x"} 그리고 전역환경(global
environment)에 있는 다른 객체들을 함께 반환합니다. 

@item
R은 0의 크기를 가진 행렬 (zero-extent matrices)와 배열 (즉, @code{dim} 속성벡터(attribute
vector)의 일부 구성요소가 0이 될 수 있습니다)를 허용합니다.  이것은 비어있는 부분집합 (empty subset)에 대한 특별한
테스트들의 필요성을 도움을 주기 때문에 유용한 기능이라고 여겨져 왔습니다.  만약, @code{x}가 행렬이며,
@code{x[,FALSE]}는 @code{NULL}이 아니라, 아무런 행을 가지지 않는 ``행렬''입니다.  그러므로, 이러한 객체들은
@code{is.null()}을 이용하는 것이 아니라 @code{length()}가 0인지를 확인해야 합니다 (R과 S 둘 다
작동합니다).

@item
벡터의 구성요소에 이름이 있는 벡터(named vector)들은 R에서는 벡터로 여겨지지만, S에서는 그렇지 않습니다 (즉,
@code{is.vector(c(a=1:3))}은 S에서 @code{FALSE}이지만, R에서는 @code{TRUE}입니다).

@item
R에서는 데이터프레임은 행렬로 여겨지지 않습니다 (즉, 만약에 @code{DF}가 데이터 프레임이라면,
@code{is.matrix(DF)}의 결과는 R에서는 @code{FALSE}이지만 S에서는 @code{TRUE}입니다).

@item
R에서는 기본적으로 순서가 없는 경우(unordered case)에는 treatment contrast를 사용하는 반면 S는
Helmert 대조를 사용합니다. 이것은 treatment contrast가 더 자연스럽다는 의견이 반영된 다른 점입니다.

@item
R에서는 우변(right hand side)에 해당하는 치환함수의 인자는 @samp{value}라고 반드시 이름지어져야 합니다.  즉,
@code{f(a) <- b}는 @code{a <- "f<-"(a, value = b)}처럼 평가됩니다.  S는 명칭에 관계없이 항상
마지막 인자를 취합니다. 

@item
S에서는 @code{substitute()}는 주어진 표현(expression)으로부터 대체에 이용될 이름들을 검색합니다:
매칭호출(matching call)의 실제적(actual) 인자와 기본(default) 인자, 그리고 이의 순서에 따른 지역적
프레임(local frame).  R은 변수가 평가되지 않았다면, ``promise''를 사용하기 위한 특별한 규칙과 함께 지역적 프레임
내를 살펴보게 됩니다.  지역적 프레임은 할당(assignment)이 일어나기 전에 실제적 인자 (actual argument) 또는
디폴트 표현(default expression)으로 초기화 되기 때문에 이는 보통 S와 일치하게 됩니다.

@item
S에서는 @code{for()} 루프내의 인덱스 변수(index variable)은 루프내에서 지역적으로 이용됩니다.  R에서는
@code{for()}문이 실행되어진 곳의 환경(environment)에 지역적입니다.

@item
S에서는 @code{tapply(simplify=TRUE)}는 R이 1-차원 배열(dimnames이라고 이름을 가질 수도 있는)을
반환하는 벡터를 반환하게 됩니다. 

@item
S(-@sc{Plus})에서는 C 로케일이 사용되는 반면 R은 현재 운영체제의 로케일이 문자들이 알파벳인지 어떻게 분류되는지를 결정하기
위해서 사용됩니다.  이것은 R 객체에 유효한 이름들(예를들면, 엑센트가 있는 문자들도 R에서는 허용될 수도 있습니다), 정렬의 순서와
비교 (@code{"aA" < "Bb"}가 참 또는 거짓인지를 결정)에 영향을 줍니다.  1.2.0 버전부터는 로케일은
@code{Sys.setlocale()}함수를 이용하여 R내부에서 재설정될 수 있습니다.

@item
S에서는 @code{missing(@var{arg})}는 만약 @var{arg}가 실제적으로 수정이 되면 @code{TRUE}로 남아있게
되나, R에서는 그렇지 않습니다. 

@item
버전 1.3.0 부터는 @code{data.frame}은 (행의) 이름을 생성할때 @code{I()}를 분해합니다.

@item
R에서는 문자열 @code{"NA"}는 문자형 변수에서 결측값(missing value)로 처리되지 않습니다.  결측을 의미하는
문자값(missing character value)를 생성하기 위해서는 @code{as.character(NA)}를 활용하세요.

@item
R은 함수호출에서 중복되는 형식인자(formal argument)를 허용하지 않습니다.

@item
S에서는 @code{dump()}, @code{dput()}, 그리고 @code{deparse()}는 같은 코드에 근본적으로 다른
인터페이스입니다.  R에서는 버전 2.0.0부터 같은 @code{control} 인자가 이용될 때에만 참(true)이지만, 기본적으로
그렇지는 않습니다.  기본적으로는 @code{dump()}는 색체를 재생산하기 위한 평가를 하는 코드를 작성하는 반면,
@code{dput()}과  @code{deparse()}는 기본적으로 읽기가 가능한 구문분석이 되지 않은 코드(deparsed
code)를 생성하기 위한 옵션들입니다.

@item
R에서는 문자벡터 인덱스(character vector index)를 이용하여 @code{[}와 함께 벡터, 행렬, 배열, 또는
데이터프레임을 인덱싱하는 것은 오로지 정확한 매치(exact matches)들만을 찾습니다 (그러나, @code{[[}와
@code{$}는 부분매치를 허용합니다).

@item
S는 두개의 인자를 가지는 @code{atan}이 있으나, @code{atan2}는 없습니다.  S에서 @code{atan(x1,
x2)}라고 호출을 하는 것은 R에서  @code{atan2(x1, x2)}라고 하는 것과 같습니다.   그러나, S의 코드
@code{atan(x=a, y=b)}는 R에서 @code{atan2(y=a, x=b)}이기 때문에 @code{x}와 @code{y}가
서로 바뀌어 있음을 아셔야 합니다.   (R은 위치인수(positional arguments)와 함께 사용되는 2개의 인자를 가지는
@code{atan}에 대하여 문서가 없이 지원을 했었으나, 이는 더이상의 혼란을 피하기 위하여 제거되었습니다).

@item
분수와 지수부분이 없는 숫자형 상수들은 in@SPLUS{} 6.x 또는 그 이후버전에서는 정수로 처리하지만, R에서는 이를
더블(double)로 처리합니다.

@end itemize

의도하지 않았지만, R에서 잘못된 코드 또는 누락된 부분으로 인한 다른 점 또한 있을 수 있습니다. 개발자들은 사용자가 찾게 되는 어떠한
결점들에 대하여 (사용자가 찾은 다른 점들에 대해서 충분하게 문서화된 보고서의 형태로서) 듣는것을 매우 감사히 여깁니다. 물론, 스스로가
변경을 해 본뒤에 이 변경이 확실하게 작동하는가를 확인해준다면 더욱 유용합니다. 

@node R은 할 수 있지만 S-PLUS는 할 수 없는 것들이 있나요?, R-plus란 무엇인가요?, R과 S 사이에 다른 점이 있나요?, R과 S
@section R은 할 수 있지만 @sc{S-Plus}는 할 수 없는 것이 있나요?

R에서 할 수 있는 거의 모든 것들은 약간의 노력만으로 @SPLUS{}로 포트할 수 있는 소스 코드들이 있기때문에 @SPLUS{}에서
하지 못하는 것을 R에서 할 수 있지는 않을 것입니다 (그러나, 렉시컬 스코핑을 이용하는 것은 상당히 문제를 단순화 시킬 수도
있습니다).

R offers several graphics features that @SPLUS{} does not, such as finer
handling of line types, more convenient color handling (via palettes), gamma
correction for color, and, most importantly, mathematical annotation in plot
texts, via input expressions reminiscent of @TeX{} constructs.  See the help
page for @code{plotmath}, which features an impressive on-line example.
More details can be found in Paul Murrell and Ross Ihaka (2000), ``An
Approach to Providing Mathematical Annotation in Plots'', @emph{Journal of
Computational and Graphical Statistics}, @strong{9}, 582--599
(@doi{10.1080/10618600.2000.10474900}).

@node R-plus란 무엇인가요?, , R은 할 수 있지만 S-PLUS는 할 수 없는 것들이 있나요?, R과 S
@section R-plus란 무엇인가요?

매우 오랜 기간동안 다음과 같은 것들은 존재하지 않았습니다. 

@c This seems gone as of 2019-10.
@c @url{http://www.xlsolutions-corp.com/, XLSolutions Corporation} is
@c currently beta testing a commercially supported version of R named R+
@c (read R plus).

Revolution Analytics has released REvolution R, now available as Microsoft R
(see
@url{https://blog.revolutionanalytics.com/2016/01/microsoft-r-open.html} for
more information).

@c Now archived at <http://archive.today/WrgxY>
@c @url{http://www.random-technologies-llc.com/, Random Technologies}
@c offers @url{http://random-technologies-llc.com/products/RStat/rstat,
@c RStat}, an enterprise-strength statistical computing environment which
@c combines R with enterprise-level validation, documentation, software
@c support, and consulting services, as well as related R-based products.

See also
@url{https://en.wikipedia.org/wiki/R_programming_language#Commercialized_versions_of_R}
for pointers to commercialized versions of R.

@node R 웹인터페이스(Web Interfaces), R Add-On Packages, R과 S, Top
@chapter R 웹인터페이스(Web Interfaces)

Please refer to the @CRAN{} task view on ``Web Technologies and Services''
(@url{https://CRAN.R-project.org/view=WebTechnologies}), specifically
section ``Web and Server Frameworks'', for up-to-date information on R web
interface packages.

Early references on R web interfaces include Jeff Banfield (1999), ``Rweb:
Web-based Statistical Analysis'' (@doi{10.18637/jss.v004.i01}), David Firth
(2003), ``CGIwithR: Facilities for processing web forms using R''
(@doi{10.18637/jss.v008.i10}), and Angelo Mineo and Alfredo Pontillo (2006),
``Using R via PHP for Teaching Purposes: R-php''
(@doi{10.18637/jss.v017.i04}).

@node R Add-On Packages, R과 이맥스(Emacs), R 웹인터페이스(Web Interfaces), Top
@chapter R Add-On Packages

@menu
* 어떤 애드온 패키지들이 존재하나요?::
* 애드온 패키지는 어떻게 설치하나요?::
* 애드온 패키지는 어떻게 사용하나요?::
* 애드온 패키지는 어떻게 제거할 수 있나요?::
* R 패키지는 어떻게 작성하나요?::
* 어떻게 R에 기여할 수 있나요?::  
@end menu

@node 어떤 애드온 패키지들이 존재하나요?, 애드온 패키지는 어떻게 설치하나요?, R Add-On Packages, R Add-On Packages
@section 어떤 애드온 패키지들이 존재하나요?

@menu
* R에서 사용할 수 있는 애드온 패키지::
* CRAN으로부터 얻을 수 있는 애드온 패키지::
* Bioconductor로부터 얻을 수 있는 애드온 패키지::
* 다른 애드온 패키지::  
@end menu

@node R에서 사용할 수 있는 애드온 패키지, CRAN으로부터 얻을 수 있는 애드온 패키지, 어떤 애드온 패키지들이 존재하나요?, 어떤 애드온 패키지들이 존재하나요?
@subsection R에서 사용할 수 있는 애드온 패키지

R은 다음과 같은 패키지들과 함께 배포됩니다.

@table @strong
@c <FIXME>
@c 3.0.0
@item base
Base R 함수들 (그리고 R 2.0.0 전의 데이터셋들).
@item compiler
(R 2.13.0에서 더해진) R 바이트 코드 컴파일러(byte code compiler).
@item datasets
(R 2.0.0에서 더해진) Base R 데이터셋들.
@item grDevices
@c </FIXME>
(R 2.0.0에 더해진) base와 grid 그래픽스를 위한 그래픽 장치들.
@item graphics
base 그래픽스를 위한 R 함수들.
@item grid
그래픽스 레이아웃 성능을 재작성하고 인터랙션을 위한 일부 지원이 추가됨.
@item methods
그린북에 설명되어 있는 것과 같이 R 객체들에 대하여 형식적으로 정의된 메소드들과 클래스들, 그리고 다른 프로그래밍 툴들.
@item parallel
포킹(forking), 소켓(sockets), 그리고 (R 2.14.0에 더해진) 난수생성(random-number generation)
기능을 포함한 병렬 연산(parallel computation)을 지원.
@item splines
리그레션 스플라인(regression spline)함수들과 클래스들.
@item stats
R 통계관련 함수들.
@item stats4
S4 클래스들을 이용한 통계 함수들.
@item tcltk
Tcl/Tk @acronym{GUI} 구성요소들에 인터페이스와 랭귀지 바인딩 (interface and language
bindings).
@item tools
패키지 개발과 관리를 위한 도구들. 
@item utils
R 유틸리티 기능
@end table
@c These ``base packages'' were substantially reorganized in R 1.9.0.  The
@c former @pkg{base} was split into the four packages @pkg{base},
@c @pkg{graphics}, @pkg{stats}, and @pkg{utils}.  Packages @pkg{ctest},
@c @pkg{eda}, @pkg{modreg}, @pkg{mva}, @pkg{nls}, @pkg{stepfun} and
@c @pkg{ts} were merged into @pkg{stats}, package @pkg{lqs} returned to the
@c recommended package @CRANpkg{MASS}, and package @pkg{mle} moved to
@c @pkg{stats4}.

@node CRAN으로부터 얻을 수 있는 애드온 패키지, Bioconductor로부터 얻을 수 있는 애드온 패키지, R에서 사용할 수 있는 애드온 패키지, 어떤 애드온 패키지들이 존재하나요?
@subsection @acronym{CRAN}으로부터 얻을 수 있는 애드온 패키지

@CRAN{}의 @file{src/contrib} 디렉토리는 R의 모든 바이너리 배포에 포함되어질
@emph{recommended}(추천) 패키지들을 포함하여 방대한 양의 애드온 패키지들을 포함하고 있습니다.

@c <FIXME>
@c 3.0.0
@table @strong
@item KernSmooth
1995년에 M. P. Wand와 M. C. Jones에 의해 쓰여진 책 ``Kernel Smoothing''을 바탕으로 한 Kernel
smoothing(커널스무딩 또는 커널평활법)을 위한 함수들(그리고 밀도추정)을 포함합니다.
@item MASS
@c (Contained in the @file{VR} bundle for R versions prior to 2.10.0.)
Functions and datasets from the main package of Venables and Ripley,
``Modern Applied Statistics with S''.
@item Matrix
@c (Recommended for R 2.9.0 or later.)
Support for spares and dense matrices
@item boot
1997년에 Cambridge University Press로부터 출판된 A. C. Davison과 D. V. Hinkley에 의해
쓰여진 ``Bootstrap Methods and Their Applications''이라는 책으로부터
부츠트랩핑(bootstrapping)에 이용된 함수들과 데이터셋들을 포함하고 있습니다.
@item class
@c (Contained in the @file{VR} bundle for R versions prior to 2.10.0.)
Functions for classification (@math{k}-nearest neighbor and LVQ).
@item cluster
클러스터 분석(cluster analysis)를 위한 함수들이 포함되어 있습니다.
@item codetools
@c (Recommended for R 2.5.0 or later.)
Code analysis tools.
@item foreign
Minitab, S, SAS, SPSS, Stata, Systat등과 같은 통계 소프트웨어에 의해 저장된 데이터르르 읽고 쓰는데 필요한
함수들이 포함되어 있습니다. 
@item lattice
트렐리스(Trellis) 그래픽 함수들의 구현체인 라띠스(lattice) 그래픽스가 포함되어 있습니다.
@item mgcv
GCV 또는 UBRE을 이용한 multiple soomthing parameter selection을 포함한 GAM 그리고 다른
generalized ridge regression 문제들을 위한 루틴들이 포함되어 있습니다. 
@item nlme
가우시안(Gaussian) 선형과 비선형의 혼합 모델들(linear and nonlinear mixed-effects models)을
적합하고 비교하는 함수들이 포함되어 있습니다.
@item nnet
@c (Contained in the @file{VR} bundle for R versions prior to 2.10.0.)
Software for single hidden layer perceptrons (``feed-forward neural
networks''), and for multinomial log-linear models.
@item rpart
재귀적 파티셔닝(recursive partioning)과 회귀나무(regression trees)를 수행하는 함수들이 포함되어 있습니다.
@item spatial
@c (Contained in the @file{VR} bundle for R versions prior to 2.10.0.)
Functions for kriging and point pattern analysis from ``Modern Applied
Statistics with S'' by W. Venables and B. Ripley.
@item survival
벌점가능성 함수(penalized likelihood)함수를 포함한 생존분석(survival analysis)에 필요한 함수들을 포함하고
있습니다.
@end table
@c </FIXME>
See the @url{https://CRAN.R-project.org/web/packages/, , @CRAN{} contributed
packages page} for more information.

Many of these packages are categorized into
@url{https://CRAN.R-project.org/web/views/, @CRAN{} Task Views}, allowing to
browse packages by topic and providing tools to automatically install all
packages for special areas of interest.

@c Some @CRAN{} packages that do not build out of the box on Windows,
@c require additional software, or are shipping third party libraries for
@c Windows cannot be made available on @CRAN{} in form of a Windows binary
@c packages.  Nevertheless, some of these packages are available at the
@c ``@CRAN{} extras'' repository at
@c @url{https://www.stats.ox.ac.uk/pub/RWin/} kindly provided by Brian
@c D. Ripley.  Note that this repository is a default repository for recent
@c versions of R for Windows.

@c @node Add-on packages from Omegahat, Add-on packages from Bioconductor, Add-on packages from CRAN, Which add-on packages exist for R?
@c @subsection Add-on packages from Omegahat

@c The @url{http://www.omegahat.net/, Omega Project for Statistical
@c Computing} provides a variety of open-source software for statistical
@c applications, with special emphasis on web-based software, Java, the
@c Java virtual machine, and distributed computing.  A @acronym{CRAN} style
@c R package repository is available via @url{http://www.omegahat.net/R/}.
@c See @url{http://www.omegahat.net/} for information on most R packages
@c available from the Omega project.

@node Bioconductor로부터 얻을 수 있는 애드온 패키지, 다른 애드온 패키지, CRAN으로부터 얻을 수 있는 애드온 패키지, 어떤 애드온 패키지들이 존재하나요?
@subsection Bioconductor로부터 얻을 수 있는 애드온 패키지

@url{https://www.bioconductor.org/, Bioconductor} is an open source and open
development software project for the analysis and comprehension of genomic
data.  Most Bioconductor components are distributed as R add-on packages.
Initially most of the
@url{https://bioconductor.org/packages/release/BiocViews.html#___Software,
Bioconductor software packages} focused primarily on DNA microarray data
analysis.  As the project has matured, the functional scope of the software
packages broadened to include the analysis of all types of genomic data,
such as SAGE, sequence, or SNP data.  In addition, there are metadata
(annotation, CDF and probe) and experiment data packages.  See
@url{https://master.bioconductor.org/install/} for available packages and a
complete taxonomy via BioC Views.

@node 다른 애드온 패키지, , Bioconductor로부터 얻을 수 있는 애드온 패키지, 어떤 애드온 패키지들이 존재하나요?
@subsection 다른 애드온 패키지

Many more packages are available from places other than the default
repositories discussed above (@CRAN{} and Bioconductor).  In particular,
R-Forge provides a @CRAN{} style repository at
@url{https://R-Forge.R-project.org/}.

더 많은 코드들이 R-help 메일링 리스트에 올라오고 있으며, 메일링 리스트 보관소로부터 이들을 확인할 수 있습니다.

@node 애드온 패키지는 어떻게 설치하나요?, 애드온 패키지는 어떻게 사용하나요?, 어떤 애드온 패키지들이 존재하나요?, R Add-On Packages
@section 애드온 패키지는 어떻게 설치하나요?

(Unix-like only.)  The add-on packages on @CRAN{} come as gzipped tar files
named @code{@var{pkg}_@var{version}.tar.gz}.  Let @var{path} be the path to
such a package file.  Provided that @command{tar} and @command{gzip} are
available on your system, type

@example
$ R CMD INSTALL @var{path}/@var{pkg}_@var{version}.tar.gz
@end example

@noindent
위 명령문은 라이브러리 검색경로 (library search path)내 첫번째 디렉토리에서 갈려져 나오는 라이브러리 트리(library
tree)를 설치하게 해줍니다.  (검색경로가 어떻게 결정되는지에 대한 자세한 사항은 @code{.libPaths()}에 대한 도움말
페이지를 살펴보시길 바랍니다).

또 다른 트리 (예: 개인의 비공개 트리) 를 설치하려면 아래와 같이 입력하세요.

@example
$ R CMD INSTALL -l @var{lib} @var{path}/@var{pkg}_@var{version}.tar.gz
@end example

@noindent
여기에서 @var{lib}는 설치를 하고자 하는 라이브러리 트리(library tree)에 대한 경로를 의미합니다.

만약 @CRAN{}과 같은 저장소들에 접근할 수 있다면, 더욱 더 편리하게 사용자는 R 내에서 패키지들을 설치하고 이들을 자동으로
업데이트 할 수 있습니다.  이에 대한 더 많은 정보들을 @code{available.packages()}의 도움말 페이지로부터 찾을 수
있습니다. 

@c <COMMENT>
@c This is really no longer quite accurate (R_LIBS_USER is preferred to
@c R_LIBS), and described in ?libPaths anyways ... hence comment out.
@c You can use several library trees of add-on packages.  The easiest way
@c to tell R to use these is via the environment variable @env{R_LIBS}
@c which should be a colon-separated list of directories at which R library
@c trees are rooted.  You do not have to specify the default tree in
@c @env{R_LIBS}.  E.g., to use a private tree in @file{$HOME/lib/R} and a
@c public site-wide tree in @file{/usr/local/lib/R-contrib}, put

@c @example
@c R_LIBS="$HOME/lib/R:/usr/local/lib/R-contrib"; export R_LIBS
@c @end example

@c @noindent
@c into your (Bourne) shell profile or even preferably, add the line

@c @example
@c R_LIBS="~/lib/R:/usr/local/lib/R-contrib"
@c @end example

@c @noindent
@c your environment (e.g., @file{~/.Renviron}) file.  (Note that no
@c @code{export} statement is needed or allowed in this file; see the
@c on-line help for @code{Startup} for more information.)

@node 애드온 패키지는 어떻게 사용하나요?, 애드온 패키지는 어떻게 제거할 수 있나요?, 애드온 패키지는 어떻게 설치하나요?, R Add-On Packages
@section 애드온 패키지는 어떻게 사용하나요?

아래의 명령문은 사용자의 시스템에 이용이 가능한 추가적인 패키지들을 확인하기 위한 것 입니다. 

@example
library()
@end example

@noindent
위의 명령문을 R 프롬프트에서 입력합니다.  

다음과 같은 결과를 생성해 줄 것입니다.

@quotation
@cartouche
@smallexample
Packages in `/home/me/lib/R':

mystuff       My own R functions, nicely packaged but not documented

Packages in `/usr/local/lib/R/library':

KernSmooth    Functions for kernel smoothing for Wand & Jones (1995)
MASS          Support Functions and Datasets for Venables and Ripley's MASS
Matrix        Sparse and Dense Matrix Classes and Methods
base          The R Base package
boot          Bootstrap R (S-Plus) Functions (Canty)
boot          Bootstrap Functions (Originally by Angelo Canty for S)
class         Functions for Classification
cluster       "Finding Groups in Data": Cluster Analysis Extended
              Rousseeuw et al.
codetools     Code Analysis Tools for R
datasets      The R Datasets Package
foreign       Read Data Stored by Minitab, S, SAS, SPSS, Stata, Systat,
              dBase, ...
grDevices     The R Graphics Devices and Support for Colours and Fonts
graphics      The R Graphics Package
grid          The Grid Graphics Package
lattice       Lattice Graphics
methods       Formal Methods and Classes
mgcv          GAMs with GCV/AIC/REML smoothness estimation and GAMMs
              by PQL
nlme          Linear and Nonlinear Mixed Effects Models
nnet          Feed-forward Neural Networks and Multinomial Log-Linear
              Models
rpart         Recursive Partitioning
spatial       Functions for Kriging and Point Pattern Analysis
splines       Regression Spline Functions and Classes
stats         The R Stats Package
stats4        Statistical functions using S4 Classes
survival      Survival analysis, including penalised likelihood
tcltk         Tcl/Tk Interface
tools         Tools for Package Development
utils         The R Utils Package
@end smallexample
@end cartouche
@end quotation

설치된 패키지 @var{pkg}를 다음과 같은 방법으로 로드할 수 있습니다.

@example
library(@var{pkg})
@end example

어떤 함수들이 해당 패키지들로부터 제공되는지 아래에 나열된 명령어들 중 하나를 입력해봄으로서 확인할 수 있습니다.

@example
library(help = @var{pkg})
help(package = @var{pkg})
@end example

사용자는 다음과 같은 방법으로 패키지 @var{pkg}를 로드하거나 언로드 할 수 있습니다.

@example
detach("package:@var{pkg}", unload = TRUE)
@end example

@noindent
(여기에서 @code{unload=TRUE}는 네임스페이스가 있는 패키지들에만 필요합니다. @code{?unload}를 살펴보세요).

@node 애드온 패키지는 어떻게 제거할 수 있나요?, R 패키지는 어떻게 작성하나요?, 애드온 패키지는 어떻게 사용하나요?, R Add-On Packages
@section 애드온 패키지는 어떻게 제거할 수 있나요?

아래는 패키지를 제거할때 사용합니다.

@example
$ R CMD REMOVE @var{pkg_1} @dots{} @var{pkg_n}
@end example

@noindent
to remove the packages @var{pkg_1}, @dots{}, @var{pkg_n} from the library
tree rooted at the first directory given in @env{R_LIBS} if this is set and
non-null, and from the default library otherwise.

@c (Versions of R prior to 1.3.0 removed from the default library by default.)

라이브러리 @var{lib}으로부터 제거하기 위해서는 아래와 같이 입력하세요. 

@example
$ R CMD REMOVE -l @var{lib} @var{pkg_1} @dots{} @var{pkg_n}
@end example

@node R 패키지는 어떻게 작성하나요?, 어떻게 R에 기여할 수 있나요?, 애드온 패키지는 어떻게 제거할 수 있나요?, R Add-On Packages
@section R 패키지는 어떻게 작성하나요?

패키지는 @file{DESCRIPTION}을 포함하는 서브디렉토리와 @file{R}, @file{data}, @file{demo},
@file{exec}, @file{inst}, @file{inst}, @file{man}, @file{po}, @file{src},
그리고 @file{tests}라는 서브디렉토리들로 구성되어 있습니다 (이들 중 몇가지는 빠질 수도 있습니다).  패키지 서브디렉토리느느
또한 @file{INDEX}, @file{NAMESPACE}, @file{configure}, @file{cleanup},
@file{LICENSE}, @file{LICENCE}, @file{COPYING}, 그리고 @file{NEWS} 파일들을 포함할 수도
있습니다.

@ifclear UseExternalXrefs
더 자세한 사항은 @cite{Writing R Extensions} 문서의 ``Creating R packages'' 섹션을
살펴보세요.  이 매뉴얼은 R 배포에 포함되어 있으며 @pxref{What documentation exists for R?}, 패키지의
구조, 설정(configure)과 클린업(cleanup) 메카니즘, 그리고 패키지의 확인(checking)과 구축(building)에
대한 정보를 제공합니다.
@end ifclear
@ifset UseExternalXrefs
더 자세한 사항은 @xref{Creating R packages, , Creating R packages, R-exts, Writing
R Extensions}를 살펴보시길 바랍니다.
@end ifset

디렉토리들을 지정하고, 데이터와 코드를 저장하며, R함수들과 데이터세들에 대한 도움말 파일들의 구조를 생성하는데 사용되는 함수
@code{package.skeleton()}가 R 버전 1.3.0에서 추가되었습니다. 

@xref{CRAN이란 무엇인가요?}, @CRAN{}에 패키지를 업로드하는 방법에 대해서.

@node 어떻게 R에 기여할 수 있나요?, , R 패키지는 어떻게 작성하나요?, R Add-On Packages
@section 어떻게 R에 기여할 수 있나요?

R은 활발히 개발중이므로, 버그가 생길 수 있는 위험이 항상 존재합니다.  또한 개발자들은 R을 실행할 수 있는 모든 가능한 기계들에
대하여 접근하지 못합니다. 따라서, 이들을 이요하면서 문제들에 대해서 알려주는 것은 대단히 큰 가치를 가지고 있습니다. 

The @url{https://developer.R-project.org/, R Developer Page} acts as an
intermediate repository for more or less finalized ideas and plans for the R
statistical system.  It contains (pointers to) TODO lists, RFCs, various
other writeups, ideas lists, and SVN miscellanea.

@node R과 이맥스(Emacs), R 기타사항들(Miscellanea), R Add-On Packages, Top
@chapter R과 이맥스(Emacs)

@menu
* 이맥스에서 R을 사용할 수 있나요?::
* 이맥스 내부로부터 R을 실행해야 하나요?::
* 이맥스 내부로부터 R 디버깅하기::  
@end menu

@node 이맥스에서 R을 사용할 수 있나요?, 이맥스 내부로부터 R을 실행해야 하나요?, R과 이맥스(Emacs), R과 이맥스(Emacs)
@section 이맥스에서 R을 사용할 수 있나요?

통계 프로그램들과 통계 프로세스들 간의 기본 인터페이스를 제공하는 @acronym{ESS} (``Emacs Speaks
Statistics'') 라고 불리는 패키지가 있습니다. 이는 통계 프로그래밍과 데이터 분석간의 쌍방향 소통을 위한 지원을 제공하는 것이
목적입니다. 지원되는 언어는 R, S 3/4, 그리고 S-Plus 3.x/4.x/5.x/6.x/7.x 와 같은 S 계열의
언어들(dialects), XLispStat, ViSta와 같은 LispStat계열의 언어들, SAS, Stata, 그리고 BUGS가
있습니다.

@acronym{ESS}는 버그 수정과  S/@SPLUS{} 버전 3만을 지원하는 @acronym{GNU} Emacs 확장에 대하나
필요성에 의해서 발달하였습니다. 현재의 개발자들은 XEmacs, R, S4, 그리고 MS Windows에 대한 지원을 갈망했습니다.
게다가, R, Stata, 그리고 SAS를 위한 개발되어질 새로운 방식과 사용자 인터페이스에 대해서 표준 이맥스 사용법을 따르는 두개의
그룹모두를 도움으로서 인터페이스와 프레임워크를 하나로 통합하는 것이 사용자와 개발자 모두에게 도움이 된다고 느꼈습니다. 그 결과로
일반적인 도구를 이용하는 것보다 통계 프로그래밍과 데이터 분석에 대한 능률이 증가되게 되었습니다.

R에 대한 지원은 R 소스코드를 편집하는데 필요한 코드 (구문적 띄어쓰기, 소스코드의 하이라이팅, 코드의 부분적 평가, 코드의 로딩과
오류 체크, 그리고 소스코드 수정 관리)과 문서화 (구문적 띄어쓰기, 소스코드의 하이라이팅, 실행 중인 @acronym{ESS}
프로세스에 예제 보내기, 그리고 미리보기), Emacs 내에서 R 프로세스와의 소통 (명령어 라인 편집, 검색이 가능한 명령어 히스토리,
R 개체와 파일명에 대한 명령어 완성기능, 객체와 검색목록들에 대한 빠른 엑세스, 트랜스크립트 레코딩, 그리고 도움말과의 인터페이스),
그리고 기록의 조작 (레코딩과 트랜스크립트 파일들의 저장, 저장된 트랜스크립트의 편집과 조작, 트랜스크립 파일로부터의 명령어에 대한
재평가)를 포함합니다.

The latest stable version of @acronym{ESS} is available via @CRAN{} or the
@url{https://ESS.R-project.org/, ESS web page}.

@acronym{ESS}는 자세한 설치 사항들고 함께 주어집니다.

For help with @acronym{ESS}, send email to @email{ESS-help@@r-project.org}.

Please send bug reports and suggestions on @acronym{ESS} to
@email{ESS-bugs@@r-project.org}.  The easiest way to do this from is within
Emacs by typing @kbd{M-x ess-submit-bug-report} or using the [ESS] or [iESS]
pulldown menus.

@node 이맥스 내부로부터 R을 실행해야 하나요?, 이맥스 내부로부터 R 디버깅하기, 이맥스에서 R을 사용할 수 있나요?, R과 이맥스(Emacs)
@section 이맥스 내부로부터 R을 실행해야 하나요?

Yes, instead of just running it in a console, @emph{definitely}.  As an
alternative to other IDE's such as Rstudio, @emph{possibly}, notably if you
are interested to use Emacs for other computer interaction.  You'd be using
@acronym{ESS}, Emacs Speaks Statistics, see previous FAQ.

Inferior R mode provides a readline/history mechanism, object name
completion, and syntax-based highlighting of the interaction buffer using
Font Lock mode, as well as a very convenient interface to the R help system.

물론, 이는 Emacs를 이용하여 R 소스를 편집하기 위한 메카니즘과도 잘 합쳐집니다.  Emacs 버퍼에 코드를 작성하고, 전체 또는
부분을 실행하기 위해 R로 보낼 수 있습니다.  이것은 데이터 분석과 프로그래밍에 도움이 됩니다.  프로그램과 데이터의 변경에 대한
기록을 잘 유지하고 또한 이전 버전의 코드들을 다시 복구하기 위하여 버전관리시스템(revision control system)과도 통합할
수 있습니다.

추가로, 이는 트랜스크립트 모드(transcript mode)의 사용을 통하여 오류 복구(error recovery)에 이용될 수도 있는
세션의 기록을 보관하도록 허용합니다.

Inferior R 프로세스를 위하여 명령어 라인 인자들을 지정하기 위해서는 @kbd{C-u M-x R}을 이용하여 R을 시작하세요.

@c This prompts you for the arguments; in particular, you can increase
@c the memory size this way (@pxref{Why does R run out of memory?}).

@node 이맥스 내부로부터 R 디버깅하기, , 이맥스 내부로부터 R을 실행해야 하나요?, R과 이맥스(Emacs)
@section 이맥스 내부로부터 R 디버깅하기

``from within Emacs''(이맥스 안쪽에서) R을 디버그하기 위해서는, 몇 가지 가능성들이 있습니다.  권장되어지는 디버거
GDB가 있는 Emacs GUD (Grand Unified Debugger) 라이브러리를 사용하기 위해서는 @kbd{M-x gdb}를
입력하고 R @emph{binary}에 인자로서 경로를 줍니다. @command{gdb} 프롬프트에서 @env{R_HOME}과 필요하다면
다른 환경변수들 (즉, @kbd{set env R_HOME /path/to/R}을 이용하여, 그러나 아래도 살펴보세요)를 설정하고,
요구되어지는 인자들과 함께 바이너리를 시작합니다 (즉, @kbd{run --quiet}).

만약 @acronym{ESS}를 가지고 있다면, @option{-d gdb} 인자와 함께 inferior R 프로세스를 실행하기 위해서
@kbd{C-u M-x R @key{RET} - d @key{SPC} g d b @key{RET}}를 할 수 있습니다.

세 번째 옵션은 @acronym{ESS}(@kbd{M-x R})를 통해 inferior R 프로세스를 시작하고나서 디버그 할 프로그램 R
바이너리 (전체경로의 이름을 사용함으로서)를 주는 GUD (@kbd{M-x gdb})를 시작합니다.  현재 실행되고있는 R 프로세스의
프로세스 번호를 찾기 위해서 프로그램 @command{ps}를 사용하고, 그 프로세스에 부착하기 위해서 gdb 내에서
@code{attach} 명령을 이용합니다. 이렇게 하는 하나의 장점은 사용자가 @code{*R*}과 @code{*gud-gdb*}이라는
분리된 창을 가진다는 것입니다. @code{*R*} 창에서는 객체명완성 (object-name completion)과 같이 우리가 알고
사랑하는 모든 @acronym{ESS} 기능들이 있습니다. 

Emacs 내에서 디버깅을 위하여 GUD 모드를 사용할 떄, 코드가 들어있는 디렉토리를 현재의 작업디렉토리로 사용하고 이로부터 R
바이너리에 심볼릭 링크(symbolic link)를 만드는 것이 가장 편리하다는 것을 아마도 알게 될 수도 있습니다.  그렇게 하면
다음의 예제에서 보이는 바와 같이 @file{.gdbinit}는 코드와 함께 디렉토리 안에 계속 있고, 소스에 대한 환경과 검색경로들을
설정하는데 사용될 수 있습니다.

@example
set env R_HOME /opt/R
set env R_PAPERSIZE letter
set env R_PRINTCMD lpr
dir /opt/R/src/appl
dir /opt/R/src/main
dir /opt/R/src/nmath
dir /opt/R/src/unix
@end example

@node R 기타사항들(Miscellanea), R 프로그래밍(Programming), R과 이맥스(Emacs), Top
@chapter R 기타사항들(Miscellanea)

@menu
* 리스트의 구성요소를 어떻게 NULL로 설정하나요?::
* 작업공간을 어떻게 저장할 수 있나요?::
* 작업공간을 어떻게 정리할 수 있나요?::
* eval()과 D()를 어떻게 사용해야 하나요?::
* 왜 행렬의 차원정보가 손실되나요?::
* 자동로딩(autoloading)은 어떻게 작동하는 것인가요?::
* 옵션을 어떻게 설정해야 하나요?::
* 윈도우즈에서 파일명을 어떻게 사용해야 하나요?::
* 플랏팅을 할 때 왜 색상배정에서 에러가 생기나요?::
* 어떻게 요인을 숫자로 변환할 수 있을까요?::
* R에서 트렐리스(Trellis)를 사용할 수 있나요?::
* 인클로징과 부모환경이란 무엇인가요?::
* 플롯의 라벨에 포함된 객체의 값을 어떻게 변경하나요?::
* 유효한 이름(valid names)이란 무엇인가요?::
* R에서 GAM 모형을 사용할 수 있나요?::
* 파일을 source() 할 때 왜 결과물이 출력되지 않나요?::
* 사용자 정의 함수내에서 outer()가 왜 이상하게 작동하나요?::
* anova()로부터 나온 결과는 왜 모델 내에 주어진 요인들의 순서에 따라 달라지나요?::
* 배치모드에서 PNG 그래픽을 어떻게 생성하나요?::
* 명령어 기반의 편집기능은 어떻게 사용하나요?::
* 문자열을 어떻게 변수로 바꿀 수 있나요?::
* 왜 lattice/treliis 그래픽이 작동하지 않나요?::
* 데이터 프레임의 행들을 어떻게 정렬하나요?::
* 왜 help.start() 검색엔진이 작동하지 않나요?::
* R을 업데이트하고 나면 왜 .Rprofile이 더 이상 작동하지 않나요?::
* 모든 메소드들은 어디로 가게 되나요?::
* 축의 라벨을 어떻게 회전시킬 수 있나요?::
* read.table()의 사용이 왜 비효율적인가요?::
* What is the difference between package and library?::
* 패키지를 설치하였지만 함수가 존재하지 않습니다::
* 왜 R은 이 숫자들이 서로 같다고 하지 않는 것인가요?::
* 시간이 오래 걸리는 시뮬레이션을 수행할 때 어떻게 해야 에러를 찾을 수 있거나 무시할 수 있나요?::
* 음수의 거듭제곱이 왜 틀리나요?::
* 어떻게 해야 반복문의 매 과정으로부터 생성되는 결과를 각각의 다른 파일에 저장할 수 있나요?::
* lmer()을 사용할 때 왜 p-값을 찾을 수 없나요?::
* 왜 원하지 않는 경계선이 있나요?::
* 문자열 내부에서 왜 백슬래쉬가 이상하게 작동하나요?::
* 에러바 또는 신뢰구간은 어떻게 표시할 수 있나요?::
* 두 개의 y-축을 가진 플롯을 어떻게 생성하나요?::
* 함수의 소스코드에 어떻게 접근할 수 있나요?::
* 절편이 없는 선형모형을 적합한 뒤 summary()를 이용하면 R^2의 추정치가 왜 이상하게 나오나요?::
* Why is R apparently not releasing memory?::
* How can I enable secure https downloads in R?::
* How can I get CRAN package binaries for outdated versions of R?::  
@end menu

@c @node Why does R run out of memory?, Why does sourcing a correct file fail?, R Miscellanea, R Miscellanea
@c @section Why does R run out of memory?

@c Versions of R prior to 1.2.0 used a @emph{static} memory model.  At
@c startup, R asked the operating system to reserve a fixed amount of
@c memory for it.  The size of this chunk could not be changed
@c subsequently.  Hence, it could happen that not enough memory was
@c allocated, e.g., when trying to read large data sets into R.  In such
@c cases, it was necessary to restart R with more memory available, as
@c controlled by the command line options @option{--nsize} and
@c @option{--vsize}.

@c R version 1.2.0 introduces a new ``generational'' garbage collector,
@c which will increase the memory available to R as needed.  Hence, user
@c intervention is no longer necessary for ensuring that enough memory is
@c available.

@c The new garbage collector does not move objects in memory, meaning that
@c it is possible for the free memory to become fragmented so that large
@c objects cannot be allocated even when there is apparently enough memory
@c for them.

@c @node Why does sourcing a correct file fail?, How can I set components of a list to NULL?, Why does R run out of memory?, R Miscellanea
@c @section Why does sourcing a correct file fail?

@c Versions of R prior to 1.2.1 may have had problems parsing files not
@c ending in a newline.  Earlier R versions had a similar problem when
@c reading in data files.  This should no longer happen.

@node 리스트의 구성요소를 어떻게 NULL로 설정하나요?, 작업공간을 어떻게 저장할 수 있나요?, R 기타사항들(Miscellanea), R 기타사항들(Miscellanea)
@section 리스트의 구성요소를 어떻게 NULL로 설정하나요?

아래처럼 할수있습니다.

@example
x[i] <- list(NULL)
@end example

@noindent
이렇게 하는 것은 리스트 @code{x}의 @code{i}번째 구성요소를 @code{NULL}로 지정하게 해줍니다.  동일한 방식이
구성요소의 이름을 이용할 때도 적용됩니다. 그러나, @code{x[i]} 또는 @code{x[[i]]}를 @code{NULL}의 값을
대입하지는 마시길 바랍니다.   그 이유는 이러한 대입은 해당 구성요소 자체를 리스트로부터 삭제합니다. 

행렬 @code{x}의 행의 이름들을 없애기 위해서는 @code{rownames(x) <- NULL}를 하세요. 이러한 방법은 열의
이름들을 없애는데에도 유사하게 적용됩니다.

@node 작업공간을 어떻게 저장할 수 있나요?, 작업공간을 어떻게 정리할 수 있나요?, 리스트의 구성요소를 어떻게 NULL로 설정하나요?, R 기타사항들(Miscellanea)
@section 작업공간을 어떻게 저장할 수 있나요?

@code{save.image()} 함수는 사용자의 @code{.GlobalEnv}에 있는 객체들을 @file{.RData}의 형식으로
R의 스타트업 디렉토리에 저장합니다. (이것은 @kbd{q("yes")}라고 하는 것과 동일합니다).
@code{save.image(@var{file})}을 이용하여 다른 이름으로 저장하는 할 수도 있습니다. 

@node 작업공간을 어떻게 정리할 수 있나요?, eval()과 D()를 어떻게 사용해야 하나요?, 작업공간을 어떻게 저장할 수 있나요?, R 기타사항들(Miscellanea)
@section 작업공간을 어떻게 정리할 수 있나요?

현재 활성화 되어있는 프로그래밍 환경 (주로 @code{.GlobalEnv}를 의미함)에 있는 모든 객체를 지우려고 한다면 다음과 같이
하면 됩니다.

@example
rm(list = ls(all.names = TRUE))
@end example

@noindent
(만약 @option{all = TRUE}을 사용하지 않는다면, @samp{.}으로 시작하지 않는 객체들만이 삭제됩니다.)

@node eval()과 D()를 어떻게 사용해야 하나요?, 왜 행렬의 차원정보가 손실되나요?, 작업공간을 어떻게 정리할 수 있나요?, R 기타사항들(Miscellanea)
@section eval()과 D()를 어떻게 사용해야 하나요?

만약 @code{eval(print(x), envir = e)} 또는 @code{D(x^2, "x")}를 실행하고자 한다면 예상치 않은
결과가 나타날 것입니다. 전자는 @code{x}를 찾을 수 없다고 하거나, 잘못된 @code{x}의 값을 출력할 것입니다.  후자는 만약
@code{x}가 존재한다면 0값을 돌려줄 수 있으며, 그렇지 않다면 에러를 보여줄 것입니다. 

두가지 경우 모두 다 불러들어온 환경 내에서 첫번째 인자가 평가되기 때문입니다.  객체의 모드가 반드시
@code{"expression"} 또는 @code{"call"}이어야 하고 그 결과가 평가되거나 미분된 것입니다. 이를 해결하기
위해서는 아래와 같이 반드시 첫번째 인자를 큰 따옴표로 묶어줘야 한다는것입니다. 

@example
R> D(expression(x^2), "x")
2 * x
@end example

이렇게 하는 것이 처음에는 다소 이상해 보일 수 있으나, 이것은 논리적으로인 것 뿐입니다.  직관적으로 작동하는 방식은 구현하기 쉬울
수도 있지만, 인자로서 변수를 포함하는 표현식 또는 호출하는 함수의 결과는 문제를 야기합니다.  예를들면, 다음과 같은 경우들입니다. 

@example
D2 <- function(e, n) D(D(e, n), n)
@end example

@noindent
또는

@example
g <- function(y) eval(substitute(y), sys.frame(sys.parent(n = 2)))
g(a * b)
@end example

더 많은 예제들을 @code{deriv()}의 도움말 페이지를 통하여 확인할 수 있습니다. 

@node 왜 행렬의 차원정보가 손실되나요?, 자동로딩(autoloading)은 어떻게 작동하는 것인가요?, eval()과 D()를 어떻게 사용해야 하나요?, R 기타사항들(Miscellanea)
@section 왜 행렬의 차원정보가 손실되나요?

하나의 열이나 행으로 이루어진 행렬은 서브스크립팅 연산(subscripting operation)에 의해 생성됩니다.  예를들면
@code{row <- mat[2,]}과 같습니다.  이는 기본적으로 벡터로 변환됩니다.  이와 유사하게 @w{2 x 3 x 1 x
4}이라는 차원을 가고 있는 배열을 서브스크립팅에 의해서 생성되어진다고 하면, 불필요한 차원을 삭제되어 @w{2 x 3 x 4}이라는
차원을 가진 배열로 강제변환이 되게 됩니다.  많은 논의를 거쳐 이는 @emph{feature}로 결정되었습니다.

이러한 경우를 방지하기 위해는 서브스크립팅을 할 때 @option{drop=FALSE}를 사용해보세요.

@example
rowmatrix <- mat[2, , drop = FALSE]  # @r{행 행렬을 만듭니다}
colmatrix <- mat[, 2, drop = FALSE]  # @r{열 행렬을 만듭니다}
a <- b[1, 1, 1, drop = FALSE]        # @r{1 x 1 x 1 의 배열을 만듭니다}
@end example

@option{drop = FALSE} 옵션은 프로그래밍을 할 때에 디펜시브하게(defensively) 사용되어야만 합니다.  예를들어, 

@example
somerows <- mat[index, ]
@end example

@noindent
위와  같은 표현에서 @code{index}의 길이가 1 이라면 행렬이 아닌 벡터를 반환하므로 에러를 불러일으킬 것입니다. 아래와 같이
고쳐 쓸수있습니다.

@example
somerows <- mat[index, , drop = FALSE]
@end example

@node 자동로딩(autoloading)은 어떻게 작동하는 것인가요?, 옵션을 어떻게 설정해야 하나요?, 왜 행렬의 차원정보가 손실되나요?, R 기타사항들(Miscellanea)
@section 자동로딩(autoloading)은 어떻게 작동하는 것인가요?

Autoloading is rarely used since packages became lazy-loaded.

R은 @code{.AutoloadEnv}이라고 불리는 특별한 환경(environment)가 있습니다.  @var{name}과
@var{pkg}가 객체의 이름과 이를 포함하는 패키지를 건네주는 문자열(string)인 곳에서
@kbd{autoload(@var{name}, @var{pkg})}를 이용하여 이 환경내에 정보를 저장하게 됩니다.  R이
@var{name}을 평가하려고 할때, 이에 해당하는 패키지 @var{pkg}를 로드하고 새로운 패키지의 환경내에서 @var{name}을
재 평가합니다. 

이러한 메카니즘을 이용하여 R은 만약 패키지가 로드되었더라도 (아직) 메모리를 차지않는 것과 같이 작동하도록 합니다.

매우 좋은 예제들이 @code{autoload()} 도움말에 있으므로 살펴보시길 바랍니다.

@node 옵션을 어떻게 설정해야 하나요?, 윈도우즈에서 파일명을 어떻게 사용해야 하나요?, 자동로딩(autoloading)은 어떻게 작동하는 것인가요?, R 기타사항들(Miscellanea)
@section 옵션을 어떻게 설정해야 하나요?

함수 @code{options()}는 R이 연산을 수행하고 이의 결과를 보여주는데 방법들에 있어서 영향을 미치는 다양한
전역(global) 옵션들을 설정하고 확인하도록 해줍니다.  @code{.Options}의 값은 이러한 옵션들의 현재 값을 가지고
있으나, 만약 당신이 미쳐버리고 싶지 않다면 (unless you want to drive yourself crazy) 가급적이면 이를
``read-only''(읽기 전용)으로 두고, 직접적으로 조절하지 마시길 바랍니다.

예를들어, 아래의 예를 살펴보세요.

@example
test1 <- function(x = pi, dig = 3) @{
  oo <- options(digits = dig); on.exit(options(oo));
  cat(.Options$digits, x, "\n")
@}
test2 <- function(x = pi, dig = 3) @{
  .Options$digits <- dig
  cat(.Options$digits, x, "\n")
@}
@end example

@noindent
위의 예제로부터 우리는 아래의 결과를 얻을 것입니다.

@example
R> test1()
3 3.14 
R> test2()
3 3.141593
@end example

실제로 쓰여지는 것은 @code{.Options}가 가지고 있는 @emph{global}(전역)값이며,
@kbd{options(OPT=VAL)}을 이용하여 이를 정확하게 업데이트 합니다.  @code{.GlobalEnv} 또는 함수환경
(function frame, 즉 frame)내에 있는 @code{.Options}내의 로컬카피(local copies)들은 조용히
무시될 것입니다.

@node 윈도우즈에서 파일명을 어떻게 사용해야 하나요?, 플랏팅을 할 때 왜 색상배정에서 에러가 생기나요?, 옵션을 어떻게 설정해야 하나요?, R 기타사항들(Miscellanea)
@section 윈도우즈에서 파일명을 어떻게 사용해야 하나요?

R은 C-스타일의 문자열조작(string handling)을 이용하기 때문에, @samp{\}를 이스케이프 문자(escape
character)와 같이 처리하게 됩니다.  예를들면 @samp{\n}은 개행문자(newline)을 입력하기 위해서 사용합니다.
@samp{\}이라는 문자가 정말로 필요할 때는 또 다른 @samp{\}을 이용하여 함께 사용해야 합니다. 

따라서, @code{"c:\\data\\money.dat"}와 같은 파일명을 작성하게 됩니다.  또한 @samp{\}를 @samp{/}로
변경하여 @code{"c:/data/money.dat"}와 같이 사용할 수도 있습니다.

@node 플랏팅을 할 때 왜 색상배정에서 에러가 생기나요?, 어떻게 요인을 숫자로 변환할 수 있을까요?, 윈도우즈에서 파일명을 어떻게 사용해야 하나요?, R 기타사항들(Miscellanea)
@section 플랏팅을 할 때 왜 색상배정에서 에러가 생기나요?

This is about a problem rarely seen with modern X11 installations.

X11 장치를 이용할 때 @code{demo("image")}와 같이 플랏팅(plotting) 할때 ``Error: color
allocation error'' (오류: 색상 할당 에러입니다)라는 메시지들 보게 될 때가 있습니다. 이것은 X의 문제이며 R과
간접적으로 관련이 있는 것입니다.  이것은 R을 실행하기 전에 어플리케이션들이 가능한 모든 색상들을 사용했을 때 발생하게 됩니다.
(얼마나 많은 색상의 사용이 가능한지는 X의 설정에 따라 다릅니다; 때때로 오로지 256색상만이 사용될 수도 있습니다).

@c One application which is notorious for ``eating'' colors is Netscape.
@c If the problem occurs when Netscape is running, try (re)starting it with
@c either the @option{-no-install} (to use the default colormap) or the
@c @option{-install} (to install a private colormap) option.

@code{X11()}의 기본값인 @code{"pseudo"}를 사용하기 대신에 @code{"pseudo.cube"}로 설정할 수도
있습니다.  더 많은 내용에 대해서는 @code{X11()} 도움말 페이지를 참고해주세요.

@c  @node Is R Y2K-compliant?, How do I convert factors to numeric?, Why does plotting give a color allocation error?, R Miscellanea
@c  @section Is R Y2K-compliant?

@c  We expect R to be Y2K compliant when compiled and run on a Y2K compliant
@c  system.  In particular R does not internally represent or manipulate
@c  dates as two-digit quantities.  However, no guarantee of Y2K compliance
@c  is provided for R.  R is free software and comes with @emph{no warranty
@c  whatsoever}.

@c  R, like any other programming language, can be used to write programs
@c  and manipulate data in ways that are not Y2K compliant.

@node 어떻게 요인을 숫자로 변환할 수 있을까요?, R에서 트렐리스(Trellis)를 사용할 수 있나요?, 플랏팅을 할 때 왜 색상배정에서 에러가 생기나요?, R 기타사항들(Miscellanea)
@section 어떻게 요인을 숫자로 변환할 수 있을까요?

R로 수치형 데이터를 읽어 들일때 (일반적으로 파일을 읽을때), 이들은 요인형(factor)로 인식되어 읽어지는 경우가 있습니다. 만약
@code{f}가 이러한 요인형 객체라면, 아래와 같이 한다면 수치형으로 다시 돌려주게 됩니다. 

@example
as.numeric(as.character(f))
@end example

@noindent
좀 더 효율적이지만, 기억하기는 어려운 방법으로는 아래와 같이 합니다. 

@example
as.numeric(levels(f))[as.integer(f)]
@end example

어떠한 경우라도 주어진 작업에 대해서 @code{as.numeric()} 또는 그 비슷한 것들을 호출하지 마시길 바랍니다 (그 이유는
@code{as.numeric()} 또는 @code{unclass()}는 내부코드들을 보여줄 것이기 때문입니다).

@node R에서 트렐리스(Trellis)를 사용할 수 있나요?, 인클로징과 부모환경이란 무엇인가요?, 어떻게 요인을 숫자로 변환할 수 있을까요?, R 기타사항들(Miscellanea)
@section R에서 트렐리스(Trellis)를 사용할 수 있나요?

추천 패키지인 @CRANpkg{lattice}는 베이스 패키지인 @pkg{grid}에 기초를 두고 있습니다.  이 패키지는 대부분의
트렐리스(Trellis) 명령어와 호환되는 그래픽 기능을 제공하고 있습니다.

사용자가 원하는 것들 중 적어도 몇 가지는 가능한 @code{coplot()}과 @code{dotchart()}를 살펴보세요.  R에서
제공하는 @code{pairs()}는 꽤 일반적이며, @code{splom()}의 대부분의 기능을 제공하고 있습니다. 또한, R의
기본적인 플랏 메소드는 플랏의 영상비(aspect ratio)를 지정 (및 장치의 크기에 따라 수정)할 수 있는 인자를 가지고
있습니다. 

(단어 ``Trellis''라는 단어가 상표(trademark)와 같이 사용되기 때문에, R에서는 이 단어를 사용하지 않습니다.  R과
같은 것들에 대해서는 ``lattice''라는 단어를 사용합니다).

@node 인클로징과 부모환경이란 무엇인가요?, 플롯의 라벨에 포함된 객체의 값을 어떻게 변경하나요?, R에서 트렐리스(Trellis)를 사용할 수 있나요?, R 기타사항들(Miscellanea)
@section 인클로징과 부모환경이란 무엇인가요?

함수내에서 당신은 아마도 두 개의 추가적인 환경들에 있는 변수들에 접근하고 싶을 수도 있습니다.  하나는
(``enclosing(인클로징)'')이라는 환경내에 정의된 함수이고, 다른 하나는 (``parent(패런트)'')로부터 실행된
환경입니다.

만약 명령어 라인에서 함수를 생성하거나 패키지내에서 로드를 하였다면, 이것의 인클로징 환경은 글로벌 작업공간(global
workspace)입니다.  만약 @code{f()}라는 함수를 @code{g()}라는 또 다른 함수내에서 정의를 했다면, 이것의
인클로징 환경은 @code{g()}내에 있는 환경입니다. 함수에 대한 인클로징 환경은 함수가 생설될때 고정됩니다. 함수
@code{f()}에 대한 인클로징 환경은 @code{envrionment(f)}를 이용하여 찾을 수 있습니다.

반면에 ``parent(패런트)''환경은 함수를 실행할 때 정의되어 집니다.  만약 명령어 라인에서 @code{lm()}를 실행하면,
이것의 패런트 환경은 글로벌 작업공간(global workspace)가 됩니다.  만약 함수 @code{f()}에서 이것이 실행된다면
이의 패런트 환경은 @code{f()}내에 있는 환경이 됩니다.  @code{parent.frame()} 또는
@code{sys.frame(sys.parent())}를 이용하여 함수의 실행에 대한 패런트 환경을 찾을 수 있습니다.

여지까지 사용자가 볼 수 있는 함수들의 인클로징 환경은 글로벌 작업공간일 것입니다.  그 이유는 대부분의 함수들의 정의된 위치가 글로벌
작업공간이기 때문입니다. 패런트 환경은 함수가 불러지는 곳이면 어디든지 될 수 있습니다.  만약 함수 @code{f()}가 다른 함수
@code{g()}안에 정의 되어 있다고 한다면, 이것은 @code{g()}함수 내에서 사용될 수 있기 때문에 패런트 환경과 인클로징
환경은 아마도 동일할 것입니다.

패런트 환경들은 모델 포뮬러(model formulas)와 같은 것들이 모든 변수들을 이용가능한 장소인, 즉, 함수가 호출된 환경에서
평가되는 것이 필요하므로 매우 중요합니다.  이것은 매번 실행에 따라 달라질 수도 있는 패런트 환경에 크게 영향을 받습니다.

인클로징 환경은 함수가 인크로징 환경내의 변수들을 다른 함수들 또는 자기 자신의 또다른 실행으로 가진 정보들을 공유하기 위하여 사용할 수
있기 때문에 중요합니다 (렉시컬 스코핑 섹션을 살펴보시길 바랍니다).  이는 함수가 매번 실행될때마다 동일한 인클로징 환경을 가져야
한다는 것을 필요로 합니다 (C에서는 이것을 정적변수(static variable)로 행하게 됩니다).

스코핑(scoping)은 어렵습니다.  예제들을 살펴보는 것이 도움이 됩니다. 왜 R과 S에서 다르게 실행이 되며, 이들이 왜 다른가를
살펴보는 것이 중요합니다. R과 S의 스코핑이 다른 점을 설명하는 하나의 방법은 S는 인클로징 환경이 항상 클로벌 작업공간인데 반해 R은
인클로징 환경이 함수가 생성되는 곳에서 발생하게 됩니다.

@node 플롯의 라벨에 포함된 객체의 값을 어떻게 변경하나요?, 유효한 이름(valid names)이란 무엇인가요?, 인클로징과 부모환경이란 무엇인가요?, R 기타사항들(Miscellanea)
@section 플롯의 라벨에 포함된 객체의 값을 어떻게 변경하나요?

종종 제목(title)과 같은 플랏 라벨(plot label)내에서 R 객체의 값을 사용하고자 할 때가 있습니다.  만약 라벨이 단순한
문자열이라면 @code{paste()}를 이용하여 쉽게 이루어지지만, 라벨이 정교한 수식을 가지는 표현일 경우에는 다소 어려움이
있습니다.  이 경우에는 연결된 문자열에 @code{parse()}를 이용하거나 수식에 대해서 @code{substitute()}를
이용합니다.  예를 들면, 만약 @code{hat}이 파라미터 @math{a}의 추정치라면, 다음과 같이 해 볼 수 있습니다.

@example
title(substitute(hat(a) == ahat, list(ahat = ahat)))
@end example

@noindent
(여기에서 @samp{==}는 @samp{=}이 아닙니다).  때때로 @code{bquote()}는 간결한 형식을 제공합니다.

@example
title(bquote(hat(a) = .(ahat)))
@end example

@noindent
여기에서 @samp{.()}내에 닫혀진 부분은 값으로 대체됩니다.

더 많은 예제들이 메일링 리스트 저장소에 있습니다.

@node 유효한 이름(valid names)이란 무엇인가요?, R에서 GAM 모형을 사용할 수 있나요?, 플롯의 라벨에 포함된 객체의 값을 어떻게 변경하나요?, R 기타사항들(Miscellanea)
@section 유효한 이름(valid names)이란 무엇인가요?

@code{data.frame()} 또는 @code{read.table()}을 이용하여 데이터 프레임을 생성하고자 할 때, R은
기본적으로 변수명이 구문상 (syntactically) 올바른지 확인하게 됩니다.  (이러한 함수들에 인자
@option{check.names}는 변수명을 확인할 것인지에 대한 여부를 조정하고 만약 필요하다면
@code{make.names()}을 이용하여 조정하게 됩니다).

어떠한 이름들이 ``유효한가''를 이해하기 위해서는 ``name''(이름)이 어떤 방법으로 사용되는가를 알아야 할 필요가 있습니다.

@enumerate
@item
A @emph{syntactic name} is a string the parser interprets as this type of
expression.  It consists of letters, numbers, and the dot and underscore
characters, and starts with either a letter or a dot not followed by a
number.  Reserved words are not syntactic names.
@item
@emph{object name}(객체명)은 표현식내에서 객체와 연관된 문자열을 의미합니다.  이 표현식은 할당연산자
(assignment operation)의 좌측에 있는 객체명을 가지거나 @code{assign()}함수에 이용되는 인자의 형태를 가지고
있습니다.  이것은 주로 구문명(syntatic name)이기도 하지만, 만약 따옴표로 묶인다면 공백을 가지지 않는 어떠한 문자열이라도
될 수 있습니다 (그리고 @code{assign()} 함수에 호출되는 된다면 이는 항상 따옴표로 묶이게 됩니다).

@item
@emph{argument name}(인자명)은 @code{f(trim=.5)}와 같이 함수호출(function call)에 사용되는
인자로서 등부호(equal sign) 좌측에 나타나는 것입니다.  인자명은 또한 구문명(syntactic name)이기도 하지만, 위와
마찬가지로 따옴표로 묶여진다면 어떤 것이든 될 수 있습니다.

@item
@emph{element name}(구성요소의 명칭 또는 요소명)은 리스트의 구성요소와 같이 객체의 조각을 구분하기 위한 문자열입니다.
이것이 @samp{$}연산자의 우측에 사용될 때에는 반드시 구문명(syntactic name)이거나 따옴표로 묶여져야 합니다.  그렇지
않다면 요소명은 어떠한 문자열이든 될 수 있습니다.  (객체가 @code{eval()} 또는 @code{attach()}에 호출될 때와
같이 데이터베이스로서 사용될 때, 요소명은 객체의 이름이 됩니다).

@item
마지막으로, @emph{file name} (파일명) 은 운영체제내에서 읽고 쓰기등을 할수있는 파일을 구분하는 문자열입니다. 사실 언어상
에서 뜻하는 이름과 별로 상관없지만, 전통적으로 이런 문자열을 "이름 (명)" 이라고 부릅니다.  
@end enumerate

@node R에서 GAM 모형을 사용할 수 있나요?, 파일을 source() 할 때 왜 결과물이 출력되지 않나요?, 유효한 이름(valid names)이란 무엇인가요?, R 기타사항들(Miscellanea)
@section R에서 GAM 모형을 사용할 수 있나요?

@CRAN{}으로부터 얻을 수 있는 패키지 @CRANpkg{gam}은 화이트 북(the White book)의 GAM 챕터에 설명된 모든
Generalized Additive Models (GAM)을 구현하였습니다.  특히, 이는 local regression과
smoothing spline를 사용하는 백피팅(backfitting)을 구현하였고, 확장할 수있습니다.  패키지
@CRANpkg{mgcv}는 GAM을 위한 @code{gam()} 함수가 있는데, 이는 화이트북에 설명된 것과 완전히 동일하지는 않습니다
(예를들면 @code{lo()}라는 것은 없습니다).  패키지 @CRANpkg{gss}는 스플라인 기반(spline-based)의
GAM을 이용할 수 있습니다.  만약 리그레션 스플라인(regression spline)을 수용한다면, @code{glm()}을 사용할
수도 있습니다.  Gaussian GAM의 경우에는 @CRANpkg{mda}라는 패키지에 있는 @code{bruto()}를 사용할 수
있습니다.

@node 파일을 source() 할 때 왜 결과물이 출력되지 않나요?, 사용자 정의 함수내에서 outer()가 왜 이상하게 작동하나요?, R에서 GAM 모형을 사용할 수 있나요?, R 기타사항들(Miscellanea)
@section 파일을 source() 할 때 왜 결과물이 출력되지 않나요?

대부분의 R 명령어들은 어떠한 결과물을 생성하지 않습니다.

@example
1+1
@end example

@noindent
위의 입력은 2 라는 값을 출력합니다.

@example
summary(glm(y~x+z, family=binomial))
@end example

@noindent
위의 명령어는 로지스틱 리그레션 모델(logistic regression model)을 적합한뒤, 요약된 정보를 산출한뒤
@code{"summary.glm"}이라는 클래스의 객체를 반환합니다 (@pxref{summary 메소드를 어떻게 작성해야 하나요?}).

만약 명령어 라인에서 @samp{1+1} 또는 @samp{summary(glm(y~x+z, family=binomial))} 이라고
입력한다면, 반환된 값들이 @code{invisible()}이 아닌 이상은 자동으로 출력됩니다.  그러나, @code{source()}를
이용하여 파일을 읽어들이거나 함수내에서 사용되는 경우에는 특별히 프린트라는 명령을 지정하지 않는 이상은 보여지지 않습니다.

이러한 값을 출력하기 위해서는 다음과 같이 해야 합니다.

@example
print(1+1)
@end example

@noindent
또는

@example
print(summary(glm(y~x+z, family=binomial)))
@end example

@noindent
혹은 @code{source(@var{file}, echo=TRUE)}라고 해야합니다.

@node 사용자 정의 함수내에서 outer()가 왜 이상하게 작동하나요?, anova()로부터 나온 결과는 왜 모델 내에 주어진 요인들의 순서에 따라 달라지나요?, 파일을 source() 할 때 왜 결과물이 출력되지 않나요?, R 기타사항들(Miscellanea)
@section 사용자 정의 함수내에서 outer()가 왜 이상하게 작동하나요?

@code{outer()}의 도움말에 명시된 것과 같이, 이는 @code{apply()}계열의 함수들이 작동하는 방식을 가지는 함수들과는
함께 쓰일 수 없습니다.  이를 사용하기 위해서는 배열의 구성요소단위별로 작동하는 벡터라이즈된 함수가 필요합니다.  코드
@code{outer(x,y, FUN)}를 보면 알 수 있듯이, 이는 @code{x}와 @code{y}의 모든 가능한 조합들을 포함하는
두 개의 큰 벡터들을 생성한 뒤, 이를 @code{FUN}에 전달하게 됩니다.  사용자의 함수는 아마도 이렇게 큰 두개의 벡터들을
파라미터로서 다룰 수 없을 것입니다.

만약 두 개의 벡터를 다룰 수는 없지만 두개의 스칼라(scalars)를 다룰 수 있는 함수를 가지고 있다면, @code{outer()}를
사용할 수는 있으나, 사용자의 함수에 이를 둘러쌓아야만 합니다.  아래와 같은 사용자 함수를 생각해 봅니다.

@example
foo <- function(x, y, happy) @{
  stopifnot(length(x) == 1, length(y) == 1) # scalars only!
  (x + y) * happy
@}
@end example

@noindent
만약, 사용자가 다음과 같이 일반적인 함수를 정의한다면, 

@example
wrapper <- function(x, y, my.fun, ...) @{
  sapply(seq_along(x), FUN = function(i) my.fun(x[i], y[i], ...))
@}
@end example

@noindent
@code{outer()}를 아래와 같이 사용할 수 있습니다. 

@example
outer(1:4, 1:2, FUN = wrapper, my.fun = foo, happy = 10)
@end example

스칼라 함수들은 @code{Vectorize()} 를 사용하여 벡터화 할수있습니다.

@node anova()로부터 나온 결과는 왜 모델 내에 주어진 요인들의 순서에 따라 달라지나요?, 배치모드에서 PNG 그래픽을 어떻게 생성하나요?, 사용자 정의 함수내에서 outer()가 왜 이상하게 작동하나요?, R 기타사항들(Miscellanea)
@section anova()로부터 나온 결과는 왜 모델 내에 주어진 요인들의 순서에 따라 달라지나요?

@code{~A+B+A:B}와 같은 모델내에서, R은 @code{~1}, @code{~A}, @code{~A+B},
@code{~A+B+A:B} 모델들의 제곱합(sums of squares)를 모두 다르게 보여줄 것입니다. 만약, 모델이
@code{~B+A+A:B}이었다면 @code{~1}, @code{~B}, @code{~A+B}, @code{~A+B+A:B} 역시
다르게 보여줄 것입니다. 첫번째의 경우에는 @code{A}에 대한 제곱합은 @code{~1}과 @code{~A}에 비교되고, 두번째의
경우에는 @code{~B}와 @code{~B+A}와 비교됩니다. 대부분의 언밸런스드 디자인(unbalanced design)인
비직교디자인(Non-orthogonal design)에서는 이러한 비교는 개념상으로나 수치연산상으로 다릅니다.

일부 패키지들은 풀모델(full model)에서 요인(factor)를 한번에 하나씩 지워나가는 모델들과 비교한 제곱합 (예를들면, SAS
에서 `Type III sums of suqares')를 보고합니다.  이는 모델에서 사용된 요인의 순서에 영향을 받지 않습니다.  어떤
종류의 제곱합이 올바른것인지에 대한 질문은 때때로 R-help에서 많은 논쟁거리를 유발합니다 (provokes low-level holy
wars). 

R이 알려주는 특정한 제곱합에 대해서는 걱정할 필요는 없습니다.  사용자가 선호하는 제곱합을 손쉽게 계산할 수 있습니다.  두 모델은
@code{anova(@var{model1}, @var{model2})}을 이용하여 비교되어지고,
@code{drop1(@var{model1})}은 한 개의 항을 빼낸뒤 얻어낸 제곱합을 보여줄 것입니다.

@node 배치모드에서 PNG 그래픽을 어떻게 생성하나요?, 명령어 기반의 편집기능은 어떻게 사용하나요?, anova()로부터 나온 결과는 왜 모델 내에 주어진 요인들의 순서에 따라 달라지나요?, R 기타사항들(Miscellanea)
@section 배치모드에서 PNG 그래픽을 어떻게 생성하나요?

Under a Unix-like, if your installation supports the @code{type="cairo"}
option to the @code{png()} device there should be no problems, and the
default settings should just work.  This option is not available for
versions of R prior to 2.7.0, or without support for cairo.  From R 2.7.0
@code{png()} by default uses the Quartz device on macOS, and that too works
in batch mode.

Earlier versions of the @code{png()} device used the X11 driver, which is a
problem in batch mode or for remote operation.  If you have Ghostscript you
can use @code{bitmap()}, which produces a PostScript or PDF file then
converts it to any bitmap format supported by Ghostscript.  On some
installations this produces ugly output, on others it is perfectly
satisfactory.  Many systems now come with Xvfb from @url{https://www.x.org/,
X.Org} (possibly as an optional install), which is an X11 server that does
not require a screen.

@c ; and there is the @CRANpkg{GDD} package from @CRAN{}, which produces
@c PNG, JPEG and GIF bitmaps without X11.

@node 명령어 기반의 편집기능은 어떻게 사용하나요?, 문자열을 어떻게 변수로 바꿀 수 있나요?, 배치모드에서 PNG 그래픽을 어떻게 생성하나요?, R 기타사항들(Miscellanea)
@section 명령어 기반의 편집기능은 어떻게 사용하나요?

R과 함께 사용되는 Unix와 같은 커맨드라인은 오로지 빌트인 커맨드 라인 편집기(inbuilt command line editor)만을
제공합니다. 이 편집기는 만약 @acronym{GNU} readline 라이브러리가 컴파일에서 R에서 설정되었을때만 불러오기, 편집하기,
이전 명령어를 재실행할 수 있습니다.  이를 위해서는 적합한 헤더(headers)를 포함하고 있는 개발버전의 readline이
필요하므로, 리눅스 바이너리 배포를 사용하는 사용자들은 @code{libreadline-dev} (Debian) 또는
@code{readline-devel} (Red Hat)과 같은 패키지가 필요할 수 있습니다.

@node 문자열을 어떻게 변수로 바꿀 수 있나요?, 왜 lattice/treliis 그래픽이 작동하지 않나요?, 명령어 기반의 편집기능은 어떻게 사용하나요?, R 기타사항들(Miscellanea)
@section 문자열을 어떻게 변수로 바꿀 수 있나요?

만약 아래와 같은 명령을 실행했다고 가정합니다. 

@example
varname <- c("a", "b", "d")
@end example

@noindent
아래의 명령문은

@example
get(varname[1]) + 2
@end example

@noindent
아래와 같은 역할을 합니다.

@example
a + 2
@end example

@noindent
또는

@example
assign(varname[1], 2 + 2)
@end example

@noindent
아래와 같은 역할을 합니다.

@example
a <- 2 + 2
@end example

@noindent
또는

@example
eval(substitute(lm(y ~ x + variable),
                list(variable = as.name(varname[1]))))
@end example

@noindent
아래와 같은 역할을 합니다.

@example
lm(y ~ x + a)
@end example

최소한 처음 두가지 경우에는 리스트(list)를 이용한 뒤, 아래와 같이 요소명을 이용하여 보다 쉽게 사용할 수 있습니다. 

@example
vars <- list(a = 1:10, b = rnorm(100), d = LETTERS)
vars[["a"]]
@end example

@noindent
이렇게 난잡하지 않게 정리할수 있습니다.

@node 왜 lattice/treliis 그래픽이 작동하지 않나요?, 데이터 프레임의 행들을 어떻게 정렬하나요?, 문자열을 어떻게 변수로 바꿀 수 있나요?, R 기타사항들(Miscellanea)
@section 왜 lattice/treliis 그래픽이 작동하지 않나요?

가장 큰 이유는 R에 그래프를 보여줄 것을 명령하는 것을 잊은 것입니다.  @code{xyplot()}과 같은 라띠스 함수(lattice
function)들은 그래프 객체를 생성하지만, 보여주지는 않습니다.  (@CRANpkg{ggplot2} 그래픽스와 @SPLUS{}의
Trellis 그래픽스 또한 마찬가지입니다).  그래프 객체를 실제적으로 보여주기 위해서는 @code{print()} 메소드를 이용해야
합니다.  커맨드 라인에서 이러한 함수들이 대화식으로 사용될때에는 자동적으로 보여지게 되지만, @code{source()}를 이용하거나
사용자가 작성한 함수내에서 이용될 때에는 명시적으로 @code{print()}를 사용해야 합니다.

@node 데이터 프레임의 행들을 어떻게 정렬하나요?, 왜 help.start() 검색엔진이 작동하지 않나요?, 왜 lattice/treliis 그래픽이 작동하지 않나요?, R 기타사항들(Miscellanea)
@section 데이터 프레임의 행들을 어떻게 정렬하나요?

데이터 프레임내에 있는 한 개 이상의 열들안에 있는 값들에 대해서 행들을 정렬하고자 한다면, @code{order()}를 이용하면
됩니다. (예를들어, @code{DF[order(DF$a, DF[["b"]]), ]} 라고 하는 것은 데이터 프레임 @code{DF}을
@code{a}와 @code{b}라는 열들을 이용하여 정렬해줍니다).

@node 왜 help.start() 검색엔진이 작동하지 않나요?, R을 업데이트하고 나면 왜 .Rprofile이 더 이상 작동하지 않나요?, 데이터 프레임의 행들을 어떻게 정렬하나요?, R 기타사항들(Miscellanea)
@section 왜 help.start() 검색엔진이 작동하지 않나요?

Since R 2.10.0, the browser-based search engine in @code{help.start()} is an
@HTML{} interface to @code{help.search()}, and should always work.  Before
that, the engine utilized a Java applet.  In order for this to function
properly, one needed a compatible version of Java installed on the system
and linked to the browser, and both Java @emph{and} JavaScript enabled in
the browser.

@node R을 업데이트하고 나면 왜 .Rprofile이 더 이상 작동하지 않나요?, 모든 메소드들은 어디로 가게 되나요?, 왜 help.start() 검색엔진이 작동하지 않나요?, R 기타사항들(Miscellanea)
@section R을 업데이트하고 나면 왜 .Rprofile이 더 이상 작동하지 않나요?

@file{NEWS} 파일을 읽어 보셨나요?  @pkg{base} 패키지에 없는 함수들을 이용하기 위해서는 올바른 패키지 네임스페이지를
지정해야만 합니다. 그 이유는 코드들은 패키지들이 로드되기 전에 실행될 것이기 때문입니다.  예를들면, 다음을 살펴보세요.	

@example
ps.options(horizontal = FALSE)
help.start()
@end example

@noindent
위의 코드들은 아래와 같이 될 필요가 있습니다.

@example
grDevices::ps.options(horizontal = FALSE)
utils::help.start()
@end example

@c <FIXME>
@c 3.0.0
@noindent
@c </FIXME>
(@code{graphics::ps.options(horizontal = FALSE)} 는 R 1.9 이후 버젼에서 가능합니다).

@node 모든 메소드들은 어디로 가게 되나요?, 축의 라벨을 어떻게 회전시킬 수 있나요?, R을 업데이트하고 나면 왜 .Rprofile이 더 이상 작동하지 않나요?, R 기타사항들(Miscellanea)
@section 모든 메소드들은 어디로 가게 되나요?

현재 많은 함수들 (특히 S3 메소드들)은 네임스페이스(namespaces)에서 보여지지 않습니다.  이렇게 하는 것은 부주의하게 잘못된
클래스들을 인자로 호출되지 않게 하는 장점이 있지만 확인하기가 더 힘들어 지게 됩니다.

S3 메소드 (즉, @code{[.terms]})에 해당하는 원시코드를 확인하고 싶다면 아래의 함수를 이용해 보세요.

@example
getS3method("[", "terms")
@end example

@noindent
패키지 @code{"bar"}의 네임스페이스 내에서 아직 내보지지 않은 함수 @code{foo()}의 원시코드를 확인하기 위해서는
@code{foo()}를 이용하세요.  사용자가 작성한 코드내에서 내보어지지 않은 함수들을 호출하려고 할때는 이렇게 사용하지 마시길
바랍니다.  그들은 아마도 어떠한 이유에서 내보어내어지지 않았거나 경고가 없이 변경될 수도 있기 때문입니다.

@node 축의 라벨을 어떻게 회전시킬 수 있나요?, read.table()의 사용이 왜 비효율적인가요?, 모든 메소드들은 어디로 가게 되나요?, R 기타사항들(Miscellanea)
@section 축의 라벨을 어떻게 회전시킬 수 있나요?

(base 그래픽스를 이용하여) 축 라벨들을 회전시키기 위해서는 @code{mtext()} 보다는 @code{text()}를 사용해야
합니다.  그 이유는 @code{par("srt")}를 지원하지 않기 때문입니다. 

@example
## @r{회전된 라벨에 공간을 주기위해 아랫쪽 마진을 넓혀줌}
par(mar = c(7, 4, 4, 2) + 0.1)
## @r{x 축과 x 축 레이블이 없는 도면 (plot)을 만듬}
plot(1 : 8, xaxt = "n",  xlab = "")
## @r{x 축에서 라벨없이 틱 마크 (tick marks)만 보이게 설정 함}
axis(1, labels = FALSE)
## @r{텍스트 라벨을 만듬}
labels <- paste("Label", 1:8, sep = " ")
## @r{x 축을 따라 라벨을 기본의 틱 마크 (tick marks) 에 맞춰 출력 함}
text(1:8, par("usr")[3] - 0.25, srt = 45, adj = 1,
     labels = labels, xpd = TRUE)
## @r{x 축 레이블을 (7개 중) 6 번째 줄에 출력 함}
mtext(1, text = "X Axis Label", line = 6)
@end example

@noindent
x 축라벨들을 플랏할때, 문자회전의 각도로 @code{srt=45}를 사용했고, 틱마크의 위치에 문자의 오른쪽 끝을 위치시키기 위해서
@code{adj=1}을 이용했으며, 플랏영역 바깥쪽의 텍스트를 위하여 @code{xpd=TRUE}가 사용되었습니다.  x축에 비례하여
위 또는 아래로 축라벨을 이동시키는데 필요한 @code{0.25} 오프셋의 값을 조정할 수도 있습니다.  더 많은 정보를 위해서는
@code{?par}를 살펴보세요.

Figure 1를 보시고, 이와 관련된 코드를 Paul Murrell (2003), ``Integrating grid Graphics
Output with Base Graphics Output'', @emph{R News}, @strong{3/2}, 7--12 에서
찾아보시길 바랍니다.

@node read.table()의 사용이 왜 비효율적인가요?, What is the difference between package and library?, 축의 라벨을 어떻게 회전시킬 수 있나요?, R 기타사항들(Miscellanea)
@section read.table()의 사용이 왜 비효율적인가요?

기본적으로 @code{read.table()}은 모든 것들을 문자형 데이터로서 읽어들인 뒤, 어떤 변수가 숫자 또는 요인으로 변경되어야
하는지에 대하여 결정을 하게 됩니다.  크기가 큰 데이터셋의 경우에는 이러한 방식은 꽤 많은 시간과 메모리를 필요로 합니다. 테이블의
열들을 어떤 클래스로 읽어들일 것인지를 지정하는데 이용되는 @code{colClasses} 인자를 사용하면 성능이 상당히 향상될 수
있습니다.

@node What is the difference between package and library?, 패키지를 설치하였지만 함수가 존재하지 않습니다, read.table()의 사용이 왜 비효율적인가요?, R 기타사항들(Miscellanea)
@section What is the difference between package and library?

@dfn{package}(패키지)는 표준화된 방식으로 코드, 데이터, 그리고 문서를 제공함으로서 R을 확장할 수 있는 자료들의
모음입니다.  @dfn{library}(라이브러리)는 R이 사용할 수 있는 (설치된) 패키지들을 찾는 디렉토리를 의미압니다.  R은 함수
@code{library}로의 호출을 통하여 패키지를 (``load(로드)''하고, 이를 검색경로에 추가하라고) 사용하라고 전달하게
됩니다.  즉, @code{library()}는 패키지들을 포함하고 있는 라이브러리들로부터 패키지를 로드하는데 쓰입니다.

더 자세한 사항은 @xref{R Add-On Packages}을 살펴보시길 바랍니다. Uwe Ligges (2003), `R Help
Desk: Package Management'', @emph{R News}, @strong{3/3}, 37--39 또한 살펴보시면 도움이
됩니다.

@node 패키지를 설치하였지만 함수가 존재하지 않습니다, 왜 R은 이 숫자들이 서로 같다고 하지 않는 것인가요?, What is the difference between package and library?, R 기타사항들(Miscellanea)
@section 패키지를 설치하였지만 함수가 존재하지 않습니다

패키지를 실제적으로 이용하기 위해서는 @code{library()}를 이용하여 로드되어져야 합니다.

See @ref{R Add-On Packages} and @ref{What is the difference between package
and library?} for more information.

@node 왜 R은 이 숫자들이 서로 같다고 하지 않는 것인가요?, 시간이 오래 걸리는 시뮬레이션을 수행할 때 어떻게 해야 에러를 찾을 수 있거나 무시할 수 있나요?, 패키지를 설치하였지만 함수가 존재하지 않습니다, R 기타사항들(Miscellanea)
@section 왜 R은 이 숫자들이 서로 같다고 하지 않는 것인가요?

The only numbers that can be represented exactly in R's numeric type are
integers and fractions whose denominator is a power of 2.  All other numbers
are internally rounded to (typically) 53 binary digits accuracy.  As a
result, two floating point numbers will not reliably be equal unless they
have been computed by the same algorithm, and not always even then.  For
example

@example
R> a <- sqrt(2)
R> a * a == 2
[1] FALSE
R> a * a - 2
[1] 4.440892e-16
R> print(a * a, digits = 18)
[1] 2.00000000000000044
@end example

함수 @code{all.equal()}은 @code{.Machine$double.eps ^ 0.5}의 오차범위내에서 두개의 객체를
비교합니다.  만약, 이보다 더 높은 수준의 정확도를 원한다면 에러전파(error propagation)을 조심스럽게 생각해보아야
합니다.

A discussion with many easily followed examples is in Appendix G
``Computational Precision and Floating Point Arithmetic'', pages 753--771 of
@emph{Statistical Analysis and Data Display: An Intermediate Course with
Examples in R}, Richard M. Heiberger and Burt Holland (Springer 2015, second
edition).  This appendix is a free download from
@url{https://link.springer.com/content/pdf/bbm:978-1-4939-2122-5/1.pdf}.

@c As of 2020-09-25, redirects to https without valid certificate ...
@c @url{http://www.validlab.com/goldberg/paper.pdf}.
@c See <https://en.wikipedia.org/wiki/IEEE_754>:
For more information, see e.g.@: David Goldberg (1991), ``What Every
Computer Scientist Should Know About Floating-Point Arithmetic'', @emph{ACM
Computing Surveys}, @strong{23/1}, 5--48, also available via
@url{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html}.

Here is another example, this time using addition:

@example
R> .3 + .6 == .9
[1] FALSE
R> .3 + .6 - .9
[1] -1.110223e-16
R> print(matrix(c(.3,  .6,  .9, .3 + .6)), digits = 18)
                     [,1]
[1,] 0.299999999999999989
[2,] 0.599999999999999978
[3,] 0.900000000000000022
[4,] 0.899999999999999911
@end example


@node 시간이 오래 걸리는 시뮬레이션을 수행할 때 어떻게 해야 에러를 찾을 수 있거나 무시할 수 있나요?, 음수의 거듭제곱이 왜 틀리나요?, 왜 R은 이 숫자들이 서로 같다고 하지 않는 것인가요?, R 기타사항들(Miscellanea)
@section 시간이 오래 걸리는 시뮬레이션을 수행할 때 어떻게 해야 에러를 찾을 수 있거나 무시할 수 있나요?

에러 대신에 @code{"try-error"}라는 클래스의 객체를 반환하고자 한다면 @code{try()}를 이용하거나, 좀 더 유연하게
다른 값을 반환할 수 있는 @code{tryCatch()}를 이용해 보세요. 예를들어, 

@example
beta[i,] <- tryCatch(coef(lm(formula, data)),
                     error = function(e) rep(NaN, 4))
@end example

@noindent
위의 예제는 성공적으로 수행된다면 @code{lm()}의 계수(coefficients)를 반환하고, 실패할 경우에는
@code{c(NaN, NaN, NaN, NaN)}을 돌려주게 됩니다 (이 경우에는 계수가 4개라고 가정했습니다).

@node 음수의 거듭제곱이 왜 틀리나요?, 어떻게 해야 반복문의 매 과정으로부터 생성되는 결과를 각각의 다른 파일에 저장할 수 있나요?, 시간이 오래 걸리는 시뮬레이션을 수행할 때 어떻게 해야 에러를 찾을 수 있거나 무시할 수 있나요?, R 기타사항들(Miscellanea)
@section 음수의 거듭제곱이 왜 틀리나요?

아마 다음과 같은 경우에 이러한 질문이 생길 수 있니다.

@example
R> -2^2
[1] -4
@end example

@noindent
이는 R의 표현식에 대한 우선순위 규칙(precedence rules)를 잘 못 이해한 경우에 해당합니다.  올바른 결과를 얻기 위해서는
다음과 같이 해야

@example
R> (-2)^2
[1] 4
@end example

@noindent
@math{-2}의 제곱에 대한 올바른 값을 얻을 수 있습니다.

우선순위 규칙은 @code{?Syntax} 내에 정리되어 있으며, 어떻게 R이 해석하는지를 알기 위해서는 구문트리(parse tree)를
보시길 바랍니다. 

@example
R> as.list(quote(-2^2))
[[1]]
`-`

[[2]]
2^2
@end example

@node 어떻게 해야 반복문의 매 과정으로부터 생성되는 결과를 각각의 다른 파일에 저장할 수 있나요?, lmer()을 사용할 때 왜 p-값을 찾을 수 없나요?, 음수의 거듭제곱이 왜 틀리나요?, R 기타사항들(Miscellanea)
@section 어떻게 해야 반복문의 매 과정으로부터 생성되는 결과를 각각의 다른 파일에 저장할 수 있나요?

이를 수행하는 한가지 방법으로는 @code{file.path()}로 경로를 지정해주면서 파일명과 각 반복단계를 나타내는 숫자를 한데
결합시켜줄 수 있는 @code{paste()} (또는 @code{sprintf()})를 이용하는 것입니다.  예를들면, 결과물을 현재의
작업디렉토리인 @file{Results}에 @file{result1.rda}, @dots{}, @file{result100.rda}이라는
파일에 저장하기 위해서는 다음과 같이 할 수 있습니다. 

@example
for(i in 1:100) @{
  ## Calculations constructing "some_object" ...
  fp <- file.path("Results", paste("result", i, ".rda", sep = ""))
  save(list = "some_object", file = fp)
@}
@end example

@node lmer()을 사용할 때 왜 p-값을 찾을 수 없나요?, 왜 원하지 않는 경계선이 있나요?, 어떻게 해야 반복문의 매 과정으로부터 생성되는 결과를 각각의 다른 파일에 저장할 수 있나요?, R 기타사항들(Miscellanea)
@section lmer()을 사용할 때 왜 @math{p}-값을 찾을 수 없나요?

r-help 리스트에 포스트된 이 질문에 대해서 Doug Bates는 매우 친절하게 폭넓은 응답을 해주었으며, 이는
@uref{https://stat.ethz.ch/pipermail/r-help/2006-May/094765.html}에서 확인할 수
있습니다.

@node 왜 원하지 않는 경계선이 있나요?, 문자열 내부에서 왜 백슬래쉬가 이상하게 작동하나요?, lmer()을 사용할 때 왜 p-값을 찾을 수 없나요?, R 기타사항들(Miscellanea)
@section PS 또는 PDF 파일로 저장된 플롯을 볼 때 왜 원치 않는 테두리, 선 또는 그리드와 같은 인공물들이 있나요?

이것은 @code{polygon()}, @code{filled.contour()}, @code{image()}, 또는 이런 함수들을
내부적으로 호출하게 되는 함수들을 이용할 때 발생합니다.  @code{polygon()}의 경우에는 @code{border}인자를
@code{NA} 또는 @code{"transparent"}로 지정해주었음에도 다각형(polygon)들 사이에 원하지 않는
경계(border)가 생기는 것을 볼 수 있을 수도 있습니다. 

이 문제의 원인은 플랏이 anti-aliased되어 있을때 PS/PDF 뷰어에 있습니다.  이 문제들의 근원은 plot이
안티얼라이스드(anti-aliased, 그래픽에서 계단식 모양의 가장자리를 제거하는 처리 과정)되었을 때의 PS/PDF 뷰어입니다.
문제해결에 대한 자세한 사항은 사용하는 뷰어 및 운영체제에 따라 다르며, 시간이 지남에 따라서 달라질 수도 있습니다. 일부 일반적인
뷰어들에서는 다음과 같이 해 볼 수 있습니다. 

@ftable @asis
@item Acrobat Reader (cross platform)
개인설정(Preference)메뉴에 텍스트 스무딩(Text smoothing), 이미지 스무딩(image smoothing)과 라인아트
스무딩(line art smoothing)을 활성/비활성하는 옵션이 있습니다. 여기에서 라인아트 스무딩을 사용하지 않도록 조정하세요.
@item Preview (macOS)
개인설정(Preference)에서 텍스트(text)와 라인아트(line art)에 대한 안티얼라이싱(anti-aliasing)을
활성/비활성하는 옵션션이 있습니다.  이 옵션을 비활성화 하세요. 
@item GSview (cross platform)
텍스트 알파(Text Alpha)와 그래픽 알파(Graphics Alpha)를 설정하도록 합니다.  그래픽 안티얼라이싱 (graphic
anti-aliasing)을 비활성화 하기 위해서 그래픽 알파를 4비트에서 1비트로 변경하세요.
@item gv (Unix-like X)
안티얼라이싱(anti-aliasing)을 활성/비활성화하는 옵션이 있습니다.  이 옵션을 비활성화하세요.
@item Evince (Linux/GNOME)
이 뷰어에서는 안티얼라이싱을 비활성 시키는 옵션이 하나도 없습니다.
@item Okular (Linux/KDE)
GUI에서 안티얼라이싱의 활성/비활성을 조절하는 옵션이 없습니다. 콘솔상에서 명령어라인으로 아래와 같이 해보세요.
@smallexample
$ kwriteconfig --file okularpartrc --group 'Dlg Performance' \
               --key GraphicsAntialias Disabled
@end smallexample
Okular를 재실행 보세요. 본래의 설정으로 되돌리기 위해서는 마지막 단어를 @samp{Enabled}로 변경하세요.
@end ftable

@node 문자열 내부에서 왜 백슬래쉬가 이상하게 작동하나요?, 에러바 또는 신뢰구간은 어떻게 표시할 수 있나요?, 왜 원하지 않는 경계선이 있나요?, R 기타사항들(Miscellanea)
@section 문자열 내부에서 왜 백슬래쉬가 이상하게 작동하나요?

이 질문은 종종 파일명과 관계되어 올라오곤 하지만 (@ref{윈도우즈에서 파일명을 어떻게 사용해야 하나요?}를 살펴보세요), 만약 어떤
특정 문자들에 뒤이어 일어나지 않는 이상 문자열로 단일 @samp{\} 문자를 넣을 수 없는 것처럼 보일때 불평이 나오곤 합니다. 

이를 이해하기 위해서는ㄴ 문자열(character strings)와 문자열의 리프레젠테이션(represenation of
character strings)를 구분해야만 합니다.  대부분의 경우에는 R에서의 리프레젠테이션(representation)은 단순히
어느쪽이 끝이던지 작은 따옴표 또는 큰 따옴표가 함께 사용된 문자열입니다.  그러나, 이런 방법으로 사용할 수 없는 문자열들이
있습니다.  이러한 것에 해당하는 것은 따옴표 문자를 포함하고 있는 문자열들입니다. 

@example
> str <- "This \"text\" is quoted"
> str
[1] "This \"text\" is quoted"
> cat(str, "\n")
This "text" is quoted
@end example

@noindent
이스케이프 시퀀스(escape sequences) 문자인 @samp{"}와 @samp{
}은 큰 따옴표와 개행을 나타냅니다.  @code{print()} 또는 프롬프트에서 이름을 입력하여 텍스트 문자열을 출력하는 것 역시
이스케이프 시퀀스를 이용합니다.  그러나, @code{cat()}함수는 문자열 그대로를 보여줄 것입니다. @samp{"\n"}은 두개가
아닌 하나의 문자임을 알아두시길 바랍니다.  백슬래쉬는 실제로 문자열내에 포함되는 것이 아니고 단지 프린트된 리프레젠테이션에서 생성된 것
뿐입니다.

@example
> nchar("\n")
[1] 1
> substring("\n", 1, 1)
[1] "\n"
@end example

어떻게 백슬래쉬를 문자열 안에 표현할 수 있나요?  이렇게 하기 위해서는 이스케이프 문자를 피해야만 합니다.  즉, 백슬래쉬를 두번
사용해야 합니다.

@example
> cat("\\n", "\n")
\n
@end example

레귤러 익스프레이션 매칭 (regular expression matching)을 이용하는 종류의 일부 함수들은 백슬래쉬 메카니즘에 의하여
피해질 필요가 있는 메타문자들(metacharacters)들을 사용합니다.  그러한 경우에는 한개의 문자를 표현하기 위해서 4개의
백슬래쉬를 써야 할 경우도 있습니다.

2.4.1Rkwlsms @samp{\p}와 같은 알려지지 않는 이스케이프 문자들은 @samp{p}로 에러의 출력없이 해석되었습니다.
현재 버전의 R은 경고를 표시합니다. 

@node 에러바 또는 신뢰구간은 어떻게 표시할 수 있나요?, 두 개의 y-축을 가진 플롯을 어떻게 생성하나요?, 문자열 내부에서 왜 백슬래쉬가 이상하게 작동하나요?, R 기타사항들(Miscellanea)
@section 에러바 또는 신뢰구간은 어떻게 표시할 수 있나요?

특정한 종류의 플랏들에 대해서 에러바를 보여주는 일부 함수들이 있습니다.  @CRANpkg{agricolae} 패키지내의
@code{bar.err()} 함수, @CRANpkg{gplots} 패키지내의 @code{plotCI()} 함수,
@CRANpkg{plotrix} 패키지내의 @code{plotCI()}와 @code{brkdn.plot()} 함수,
@CRANpkg{psych} 패키지내의 @code{error.bars()}, @code{error.crosses()}, 그리고
@code{error.bars.by()} 함수가 있습니다.  이러한 유형의 함수 중 @code{plotCI()}과 같은 몇몇 함수들은
dispersion(분산)을 계산해주고, @code{bar.err}와 @code{brkdn.plot}와 같은 것들은 원래의 값들 (raw
values)로부터의 dispersion measure(분산 측도)를 계산해주며, @code{error.bars}와 같은 것들은 두가지
모두를 제공합니다.  @code{plotrix} 패키지내에 있는 dispersion 함수와 같은 것들은 에러바들만을 보여주기도
합니다. 위에서 언급한 함수들의 대부분은 에러바를 그리기 위해서 base @pkg{graphics} 패키지 내에 있는
@code{arrows()}를 사용합니다.

위에서 언급한 함수 모두는 base graphics 시스템 (즉, base 배포에 있는 graphics 패키지를 이용한 그래픽 시스템)을
이용합니다.  grid와 lattice 그래픽 시스템들 또한 에러바를 보여주는데 필요한 특정한 함수들을 가지고 있습니다.  예를들면,
@pkg{grid} 패키지내의 @code{grid.arrow()} 함수와 @CRANpkg{ggplot2} 패키지 내의
@code{geom_errorbar()}, @code{geom_errorbarh()}, @code{geom_pointrange()},
@code{geom_linerange()}, @code{geom_crossbar()}, 그리고
@code{geom_ribbon()}함수등입니다. 라띠스 시스템에서는 @CRANpkg{Hmisc} 패키지에 있는
@code{Dotplot()} 또는 @code{xYplot()} 함수들, @CRANpkg{latticeExtra} 패키지에 있는
@code{segplot()} 함수가 에러바를 보여줄 수 있습니다. 

@node 두 개의 y-축을 가진 플롯을 어떻게 생성하나요?, 함수의 소스코드에 어떻게 접근할 수 있나요?, 에러바 또는 신뢰구간은 어떻게 표시할 수 있나요?, R 기타사항들(Miscellanea)
@section 두 개의 y-축을 가진 플롯을 어떻게 생성하나요?

@c See
@c @url{http://rwiki.sciviews.org/doku.php?id=tips:graphics-base:2yaxes}
@c for more information, including strong arguments against this sort of
@c graph.
Creating a graph with two y-axes, i.e., with two sorts of data that are
scaled to the same vertical size and showing separate vertical axes on the
left and right sides of the plot that reflect the original scales of the
data, is possible in R but is not recommended.  The basic approach for
constructing such graphs is to use @code{par(new=TRUE)} (see @code{?par});
functions @code{twoord.plot()} (in the @CRANpkg{plotrix} package) and
@code{doubleYScale()} (in the @CRANpkg{latticeExtra} package) automate the
process somewhat.

@node 함수의 소스코드에 어떻게 접근할 수 있나요?, 절편이 없는 선형모형을 적합한 뒤 summary()를 이용하면 R^2의 추정치가 왜 이상하게 나오나요?, 두 개의 y-축을 가진 플롯을 어떻게 생성하나요?, R 기타사항들(Miscellanea)
@section 함수의 소스코드에 어떻게 접근할 수 있나요?

In most cases, typing the name of the function will print its source
code. However, code is sometimes hidden in a namespace, or compiled.  For a
complete overview on how to access source code, see Uwe Ligges (2006),
``Help Desk: Accessing the sources'', @emph{R News}, @strong{6/4}, 43--45
(@url{https://CRAN.R-project.org/doc/Rnews/Rnews_2006-4.pdf}).

@node 절편이 없는 선형모형을 적합한 뒤 summary()를 이용하면 R^2의 추정치가 왜 이상하게 나오나요?, 보시다시피 왜 R은 메모리를 풀어주지 않나요?, 함수의 소스코드에 어떻게 접근할 수 있나요?, R 기타사항들(Miscellanea)
@section 절편이 없는 선형모형을 적합한 뒤 summary()를 이용하면 R^2의 추정치가 왜 이상하게 나오나요?

@code{?summary.lm}에 설명되어 있는 것과 같이 절편이 0일때 (즉, @code{y~x-1} 또는 @code{y~x+0}
이라고 사용하는 경우), @code{summary.lm()}은 다음의 포뮬러를 사용합니다. 
@ifnottex
  R^2 = 1 - Sum(R[i]^2) / Sum((y[i])^2)
@end ifnottex
@tex
$ R^2 = 1 - \sum_i R_i^2 / \sum_i y_i^2 $
@end tex
위의 포뮬러는 다음의 일반적인 포뮬러와 다릅니다.
@ifnottex
  R^2 = 1 - Sum(R[i]^2) / Sum((y[i] - mean(y))^2).
@end ifnottex
@tex
$ R^2 = 1 - \sum R_i^2 / \sum_i (y_i - \hbox{mean}(y))^2. $ 
@end tex
여기에는 다음과 같은 몇 가지의 이유들이 있습니다:
@itemize
@item
@math{R^2}는 음수가 될 수 있습니다 (절편이 없는 모델은 비교되어지는 상수-평균(constant-mean) 모델보다 설명력이 안
좋게 적합될수도 있기 때문입니다).
@item
만약 원점을 지나는 직선을 가진 모델의 기울기가 0으로 설정되면, 적합된 값 y*=0를 가지게 됩니다. 
@item
원점을 지나는 직선을 가진 모델에 상수, 즉 0이 아닌 평균을 가지는 모델은 중첩되지 않습니다.
@end itemize

만약 @math{x=0}이면 @math{E[Y]=0}이라는 것을 미리 알고 있다면 적합된 직선에 비교해야 할 `null' 모델은 모든
곳에서 @math{E[Y]=0}인, 즉 @math{x}가 어떠한 분산도 설명할 수 없는 모델입니다 (만약 @math{x=0}일 때
@math{E[Y]=0}이라는 것을 사전에 모른다면 원점을 지나는 직선에 적합하는 것은 아마도 하지 말아야 할 것입니다).

@node 보시다시피 왜 R은 메모리를 풀어주지 않나요?, 어떻게 R에서 안전한 HTTPS 다운로드를 활성화 할 수 있습니까?, 절편이 없는 선형모형을 적합한 뒤 summary()를 이용하면 R^2의 추정치가 왜 이상하게 나오나요?, R 기타사항들(Miscellanea)
@section 보시다시피 왜 R은 메모리를 풀어주지 않나요?

종종 리눅스를 이용하는 사용자들은 ``R 내부의 객체들을 지우고 @code{gc()}를 실행하여 보니
@code{ps}/@code{top}에 따르면 R 프로세스가 많은 양의 메모리를 사용하는 것으로 보인다''라는 의미와는 다른 의미로
질문이 되어집니다.

이것은 운영체제가 메모리를 인공적으로 할당하는 방법입니다.  일반적으로 운영체제가 사용되지 않은 모든 메모리를 풀어줄 수
없습니다. 극단적인 경우에, 만약 R이 거의 모든 메모리를 자유롭게 할지라도 운영체제는 자체 설계 때문에 이들 중 어떤 것이라도 풀수
없습니다.  따라서, @code{ps}와 @code{top}과 같은 도구들은 R이 메모리를 아예 사용하지 않을지라도 R 프로세스에 의하여
사용되어진 상주된 RAM의 실질적인 양을 보고하게 됩니다.  일반적으로 이러한 도구들은 프로세스의 실제 메모리 사용을 보고 하지 않고
운영체제가 해당 프로세스를 위하여 예약해 둔 것을 보고 합니다. 

간단히 말하면 이는 운영체제 내의 메모리 할당기(memory allocator)의 한계이며 이것과 관련하여 R이 할 수 있는 것은
아무것도 없습니다.  그 공간은 R이 나중에 물어볼 것이라는 기대하에 단순히 운영체제에 잡혀있습니다.  다음의 내용은 어떻게 이것이
발생되는지에 대한 다소 심도있는 답변을 줍니다. 

Most systems use two separate ways to allocate memory. For allocation of
large chunks they will use @code{mmap} to map memory into the process
address space.  Such chunks can be released immediately when they are
completely free, because they can reside anywhere in the virtual memory.
However, this is a relatively expensive operation and many OSes have a limit
on the number of such allocated chunks, so this is only used for allocating
large memory regions.  For smaller allocations the system can expand the
data segment of the process (historically using the @code{brk} system call),
but this whole area is always contiguous.  The OS can only move the end of
this space, it cannot create any ``holes''. Since this operation is fairly
cheap, it is used for allocations of small pieces of memory.  However, the
side-effect is that even if there is just one byte that is in use at the end
of the data segment, the OS cannot release any memory at all, because it
cannot change the address of that byte.  This is actually more common than
it may seem, because allocating a lot of intermediate objects, then
allocating a result object and removing all intermediate objects is a very
common practice.  Since the result is allocated at the end it will prevent
the OS from releasing any memory used by the intermediate objects.  In
practice, this is not necessarily a problem, because modern operating
systems can page out unused portions of the virtual memory so it does not
necessarily reduce the amount of real memory available for other
applications.  Typically, small objects such as strings or pairlists will be
affected by this behavior, whereas large objects such as long vectors will
be allocated using @code{mmap} and thus not affected.  On Linux (and
possibly other Unix-like systems) it is possible to use the @code{mallinfo}
system call (also see the @url{https://rforge.net/mallinfo, mallinfo}
package) to query the allocator about the layout of the allocations,
including the actually used memory as well as unused memory that cannot be
released.

@node 어떻게 R에서 안전한 HTTPS 다운로드를 활성화 할 수 있습니까?, How can I get CRAN package binaries for outdated versions of R?, 보시다시피 왜 R은 메모리를 풀어주지 않나요?, R 기타사항들(Miscellanea)
@section 어떻게 R에서 안전한 HTTPS 다운로드를 활성화 할 수 있습니까?

From R 4.2.0, @code{"libcurl"} download method is always available and used
for @acronym{HTTPS} by default on all platforms.  It has been used since R
3.3.0 everywhere but Windows where the default method @code{"wininet"} also
supported @acronym{HTTPS}.

So nothing needs to be done to access @samp{https://} websites in recent
versions of R.

@node How can I get CRAN package binaries for outdated versions of R?, , 어떻게 R에서 안전한 HTTPS 다운로드를 활성화 할 수 있습니까?, R 기타사항들(Miscellanea)
@section How can I get CRAN package binaries for outdated versions of R?

Since March 2016, Windows and macOS binaries of @CRAN{} packages for old
versions of R (released more than 5 years ago) are made available from a
central @CRAN{} archive server instead of the @CRAN{} mirrors.  To get
these, one should set the @CRAN{} ``mirror'' element of the @code{repos}
option accordingly, by something like
@example
local(@{r <- getOption("repos")
       r["CRAN"] <- "http://CRAN-archive.R-project.org"
       options(repos = r)
      @})
@end example
@noindent
(see @code{?options} for more information).

@node R 프로그래밍(Programming), R 버그(Bugs), R 기타사항들(Miscellanea), Top
@chapter R 프로그래밍(Programming)

@menu
* summary 메소드를 어떻게 작성해야 하나요?::
* 동적으로 로드된 코드를 어떻게 디버그 할 수 있나요?::
* 디버깅을 할 때 어떻게 R 객체들을 점검할 수 있나요?::
* 어떻게 해야 컴파일 플래그를 변경할 수 있나요?::
* 어떻게 S4 메소드를 디버그 할 수 있나요?::  
@end menu

@node summary 메소드를 어떻게 작성해야 하나요?, 동적으로 로드된 코드를 어떻게 디버그 할 수 있나요?, R 프로그래밍(Programming), R 프로그래밍(Programming)
@section summary 메소드를 어떻게 작성해야 하나요?

만약 @code{"foo"}라는 클래스에 대한 summary 메소드를 만들고 싶다면, @code{summary.foo()}는 아무것도
출력해서는 안됩니다.  그러나, 클래스의 객체 @code{"summary.foo"}를 반환해야 하며, summary의 정보를 보기 좋게
출력해주며 이 객체를 보이지 않게 반환하는 @code{print.summary.foo()}라는 메소드를 작성해야 합니다. 이러한 접근은
요약정보를 출력하는 @code{summary.foo()} 보다 선호됩니다. 그 이유는 때때로 함수 또는 유사한 곳의 내부에서
@code{summary()}에 의하여 계산된 결과를 사용할 필요가 때때로 있기 때문입니다.  그런 경우에 메소드 작성자는 어떠한 것도
출력되기를 원하지 않을 것입니다.

@node 동적으로 로드된 코드를 어떻게 디버그 할 수 있나요?, 디버깅을 할 때 어떻게 R 객체들을 점검할 수 있나요?, summary 메소드를 어떻게 작성해야 하나요?, R 프로그래밍(Programming)
@section 동적으로 로드된 코드를 어떻게 디버그 할 수 있나요?

대략적으로 말하면, 디버거 내에서 R을 시작할 필요가 있고, 코드를 로드하고, 인터럽트(interrupt)를 보내고,
브레이크포인트(breakpoint)을 설정해야만 합니다.

@ifclear UseExternalXrefs
@cite{Writing R Extensions} 문서에서 ``Finding entry points in dynamically
loaded code'' 섹션을 참고하시길 바랍니다. 이 매뉴얼은 R 배포에 포함되어 있습니다, @pxref{What
documentation exists for R?}.
@end ifclear
@ifset UseExternalXrefs
@xref{Finding entry points, , Finding entry points in dynamically loaded
code, R-exts, Writing R Extensions}.
@end ifset

@node 디버깅을 할 때 어떻게 R 객체들을 점검할 수 있나요?, 어떻게 해야 컴파일 플래그를 변경할 수 있나요?, 동적으로 로드된 코드를 어떻게 디버그 할 수 있나요?, R 프로그래밍(Programming)
@section 디버깅을 할 때 어떻게 R 객체들을 점검할 수 있나요?

가장 편리한 방법은 심볼릭 디버거(symbolic debugger)로부터 @code{R_PV}를 호출하는 것입니다.

@ifclear UseExternalXrefs
@cite{Writing R Extensions} 문서에서 ``Inspecting R objects when debugging'' 섹션을
참고 하십시요.
@end ifclear
@ifset UseExternalXrefs
@xref{Inspecting R objects, , Inspecting R objects when debugging, R-exts,
Writing R Extensions}.
@end ifset

@node 어떻게 해야 컴파일 플래그를 변경할 수 있나요?, 어떻게 S4 메소드를 디버그 할 수 있나요?, 디버깅을 할 때 어떻게 R 객체들을 점검할 수 있나요?, R 프로그래밍(Programming)
@section 어떻게 해야 컴파일 플래그를 변경할 수 있나요?

R로 dynloading하기위한 C 코드 파일이 있지만, 기본값(R이 빌드되었을때 정해놓은)이 아닌 컴파일레이션 플래그들을 가지고 있는
@code{R CMD SHLIB}를 사용하고 싶다고 가정합니다.

R 2.1.0 부터 사용자는 디폴트 플래그를 덮어쓰기 위하여 @file{$@env{HOME}/.R}내에 있는 개인 Makevars
설정파일을 제공합니다.
@ifclear UseExternalXrefs
See section ``Add-on packages'' in @cite{R Installation and Administration}.
@end ifclear
@ifset UseExternalXrefs
@xref{Add-on packages, , Add-on packages, R-admin, R Installation and
Administration}.
@end ifset

@c For earlier versions of R, you could change the file
@c @file{@var{R_HOME}/etc/Makeconf} to reflect your preferences, or (at
@c least for systems using @acronym{GNU} Make) override them by the
@c environment variable @env{MAKEFLAGS}.
@c @ifclear UseExternalXrefs
@c See section ``Creating shared objects'' in @cite{Writing R Extensions}.
@c @end ifclear
@c @ifset UseExternalXrefs
@c @xref{Creating shared objects, , Creating shared objects, R-exts,
@c Writing R Extensions}.
@c @end ifset

@node 어떻게 S4 메소드를 디버그 할 수 있나요?, , 어떻게 해야 컴파일 플래그를 변경할 수 있나요?, R 프로그래밍(Programming)
@section 어떻게 S4 메소드를 디버그 할 수 있나요?

브라우저로 호출을 추가하기 위하여 인자 @code{signature=}와 함께 @code{trace()} 함수를 이용하거나 상응하는
서명에 대해서 디스패치될 다른 코드를 이용하세요. 더 자세한 내용은 @code{?trace}를 참조하세요.

@node R 버그(Bugs), 감사의 말씀(Acknowledgements), R 프로그래밍(Programming), Top
@chapter R 버그(Bugs)

@menu
* 버그가 무엇인가요?::
* 버그를 보고하는 방법::  
@end menu

@node 버그가 무엇인가요?, 버그를 보고하는 방법, R 버그(Bugs), R 버그(Bugs)
@section 버그가 무엇인가요?

만약 R이 정의되어 있는 방식대로 작동하지 않거나, 운영체제로부터의 프로그램에 문제가 있다 (디스크가 꽉 찼다는 것과 반대)는
에러메시지와 함께 프로그램이 죽는다면 이는 확실히 버그입니다.  만약 @code{.C()}, @code{.Fortran()},
@code{.External()}, 또는 @code{.Call()} (또는 @code{.Internal()}), 작성한 함수내에서
자기자신을 호출할때, 잘못된 인자유형을 사용하면 R은 작동하지 않을 수도 있습니다.  이것은 버그가 아닙니다.

명령을 수행시 명령이 끝나지 않고 계속 지속되는 것은 버그일 수도 있으나, 이것이 정말 R의 잘못인지를 반드시 확인해 보아야
합니다. 일부 명령어들은 단순히 오랜 시간이 걸릴 수도 있기 때문입니다.  만약 입력이 빨리 프로세스 되어야 한다는 것을 명백히 알고
있다면, 버그로 보고하시길 바랍니다.  만약에 명령어가 오래 걸릴지 안 걸릴지를 확신할 수 없다면 도움을 청하거나 매뉴얼을 읽어보면서
이를 알아내길 바랍니다. 

만약 익숙한 명령어가 정상적으로 작동해야 할 경우에 에러메시지를 발생시킨다면, 이것은 아마도 버그일 것입니다.  만약 명령어가 잘못된
작업을 수행한다면, 이는 버그입니다.  그러나, 사용자는 반드시 무엇이 수행되어야 하는지를 반드시 알고 있어야 합니다.  만약 명령어가
익숙한 것이 아니라면 또는 어떻게 명령어가 작동되는가를 정확히 모른다면, 실제로 정상적으로 작동하는 것일 수도 있습니다.  예를들면,
일부 사용자들은 때때로 R의 수학적 연산에 버그가 있다고 생각합니다.  그러나, 이는 finite-precision arithmetic
work를 이해하지 못하기 때문입니다. 결론을 내리기 전에 문제를 확실히 알고있는 누군가에게 보여주길 바랍니다.  예를들어
@code{0.28 * 100 != 28} 또는 @code{0.1 + 0.2 != 0.3}과 같은 것은 버그가 아닙니다.  더 자세한
사항은 @xref{왜 R은 이 숫자들이 서로 같다고 하지 않는 것인가요?}를 참고해주세요.

마지막으로, 명령어의 계획된 정의가 통계분석에 가장 잘 맞는 것은 아닙니다.  이것은 매우 중요한 문제이기도 한데, 이는 또한 문제에
대한 판단의 문제이기도 합니다.  또한, 이들은 이전에 존재하는 기능들에 대해서 모르기 때문에 내리는 결론이기도 합니다.  이러한 종류의
문제에 대해서는 일반적인 방법으로 문서를 확인하고, 이를 제대로 이해했다고 확신한뒤, 원하는 무엇인가를 이용가능하지 않다는 것을 확실하게
알기전까지는 불평하지 않는 것이 좋습니다.  만약 매뉴얼을 정독한 후에도 명령어가 어떻게 무엇을 수행해야 하는지를 정확히 이해할 수
없다면, 이는 매뉴얼에 버그가 있음을 의미합니다.  매뉴얼의 역할은 모든 것을 확실히 보여주는 것입니다.  프로그램 버그도 중요하지만
문서의 버그를 보고하는 것도 중요합ㄴ디ㅏ.  그런데, introductory documentation은 심각하게 불충분하다는 것을 알고
이미 알고 있기 때문에 이것을 보고할 필요는 없습니다.

만약 함수의 온라인 인자목록이 매뉴얼과 일치하지 않는다면, 둘 중에 하나가 잘 못된 것이므로 버그로 보고해 주시길 바랍니다.

See also ``Making sure it's a bug'' in
@uref{https://www.r-project.org/bugs.html, Bug Reporting in R} for more
information.

@node 버그를 보고하는 방법, , 버그가 무엇인가요?, R 버그(Bugs)
@section 버그를 보고하는 방법

버그가 있다고 판단될때, 이것을 보고하는 것도 중요하고, 어떻게 잘 보고하는가도 중요합니다.  가장 좋은 방법은 쉘 커맨드에서 R을
입력하면서부터 문제가 발생한 부분까지의 사용된 명령어들에 대한 설명을 제공하는 것입니다.  항상 사용하는 R의 버전, 사용기기,
운영체제를 함께 알려주시길 바랍니다. 이들에 대한 정보는 @kbd{version}이라고 입력하면 출력됨을 확인할 수 있습니다.

버그를 보고할 때 가장 중요한 원칙은 가설이나 분류를 하지 않고 실제 일어난 사실들만을 보고 하는 것입니다.  사실만을 보고하는 것이 더
쉬움에도 불구하고, 많은 분들은 이러한 사실이 왜 일어났는가를 설명하곤 합니다.  만약 이러한 설명들이 R이 어떻게 구현되었는가에 대한
추측에 기초한 것이라면, 쓸모가 없을 것입니다. 그 이유는 그러한 추측이 나오게 된 어떤 사실들을 밝혀내야만 하기 때문입니다. 때때로
이것은 불가능합니다. 그러나, 대부분의 경우에는 문제를 고치려고 노력하는 사람에게는 불필요한 일입니다.

예를들어, 꽤 큰 크기의 데이터셋을 가지고 있다고 가정하고, 다음과 같은 명령어를 입력합니다.

@example
R> data.frame(x, y, z, monday, tuesday)
@end example

@noindent
이것은 절대로 반환되지 않습니다.  @code{data.frame()}이 큰 데이터셋에서 실패했다고 보고하지는 말아 주세요.  아마도
변수명이 요일로 되어 있을 때 실패하는 것일수도 있습니다. data.frame()이 큰 데이터에 대해 실패했다고 보고하지 마십시오.
만약 정말 그러하다면 다른 사람들이 보고되어진 것을 보았을때 요일명이 아닌 변수명을 이용하여 아무런 문제가 일어나지 않는 것을 확인할
것입니다.

혹은 마지막으로 사용한 명령어가 내부 데이터 구조에 오류를 발생시키고 그 이후부터 @code{data.frame()} 명령어가 실패하게
되는 원인을 가진 버그를 가졌던 @code{"["()}에 대한 메소드일 수도 있기 때문입니다.  이것은 왜 어떤 명령어들이
(시작파일부터) 이전에 입력되었는가를 알아야 하는 이유이기도 합니다.

It is very useful to try and find simple examples that produce apparently
the same bug, and somewhat useful to find simple examples that might be
expected to produce the bug but actually do not.  If you want to debug the
problem and find exactly what caused it, that is wonderful.  You should
still report the facts as well as any explanations or solutions.  Please
include an example that reproduces (e.g.,
@url{https://en.wikipedia.org/wiki/Reproducibility}) the problem, preferably
the simplest one you have found.

@option{--vanilla} 옵션과 함께 R을 실행하는 것은 버그를 분리해 내는데 도움을 줄 것입니다.  이것은 사이트 프로파일과
저장된 데이터 파일들이 읽혀지지 않도록 합니다.

Before you actually submit a bug report, you should check whether the bug
has already been reported and/or fixed.  First, try the ``Show open bugs
new-to-old'' or the search facility on @url{https://bugs.R-project.org/}.
Second, consult @url{https://svn.R-project.org/R/trunk/doc/NEWS.Rd}, which
records changes that will appear in the @emph{next} release of R, including
bug fixes that do not appear on the Bug Tracker.  Third, if possible try the
current r-patched or r-devel version of R.  If a bug has already been
reported or fixed, please do not submit further bug reports on it.  Finally,
check carefully whether the bug is with R, or a contributed package.  Bug
reports on contributed packages should be sent first to the package
maintainer, and only submitted to the R-bugs repository by package
maintainers, mentioning the package in the subject line.

A bug report can be generated using the function @code{bug.report()}.  For
reports on R this will open the R Bugzilla page at
@url{https://bugs.R-project.org/}: for a contributed package it will open
the package's bug tracker Web page or help you compose an email to the
maintainer.  Since 2016, only ``members'' (including all who have previously
submitted bugs) can submit new bugs on the R Bugzilla.  See ``Where to
submit bug reports and patches'' on
@uref{https://www.r-project.org/bugs.html, Bug Reporting in R} for more
information.

@samp{wishlist}라고 라벨과 함께 R의 기능강화에 관한 제안들을 위한 버그저장소 섹션이 있습니다.  제안사항들은 버그를
보고하는 것과 같은 방법으로 할 수 있으나, 제목에 반드시 이것은 wishlist 이지 버그리포트가 아니라는 것을 명시해주셔야 합니다.
예를들면, @samp{Wishlist:} 라고 시작해 주시면 됩니다.

R의 Windows 포트에 대한 조언 및 제안사항들은 @email{R-windows@@R-project.org}로 보내져야 합니다.

Corrections to and comments on message translations should be sent to the
last translator (listed at the top of the appropriate @samp{.po} file)  or
to the translation team as listed at
@url{https://developer.R-project.org/TranslationTeams.html}.

@node 감사의 말씀(Acknowledgements), , R 버그(Bugs), Top
@chapter 감사의 말씀(Acknowledgements)

R 시스템에 대하여 로버트(Robert)와 로스(Ross)에게 감사의 뜻을 전달하며, 이 시스템이 확장되도록 도와준 패키지 작성자 및
포터(porters)들에게 또한 감사드립니다.

특히 본 @acronym{FAQ} 문서가 발전될 수 있도록 조언을 아끼지 않은 Doug Bates, Peter Dalgaard, Paul
Gilbert, Stefano Iacus, Fritz Leisch, Jim Lindsey, Thomas Lumley, Martin
Maechler, Brian D. Ripley, Anthony Rossini, 그리고 Andreas Weingessel에게 감사드립니다.

더 많은 내용들이 추가될 것입니다@dots{}

@bye

@c Local Variables: ***
@c mode: TeXinfo ***
@c End: ***
